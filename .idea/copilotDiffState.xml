<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/ecohand/ml/VowelSignValidator.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/ecohand/ml/VowelSignValidator.kt" />
              <option name="originalContent" value="package com.example.ecohand.ml&#10;&#10;import com.google.mediapipe.tasks.vision.handlandmarker.HandLandmarkerResult&#10;import kotlin.math.*&#10;&#10;/**&#10; * Validador de señas para vocales en lenguaje de señas&#10; * Analiza landmarks de MediaPipe para determinar si una seña es correcta&#10; */&#10;class VowelSignValidator {&#10;&#10;    companion object {&#10;        private const val FINGER_THRESHOLD = 0.1f // Umbral para determinar si un dedo está extendido&#10;        private const val ANGLE_THRESHOLD = 30f // Umbral para ángulos en grados&#10;        private const val MOVEMENT_THRESHOLD = 0.15f // Umbral mínimo de movimiento para detectar el arco&#10;        private const val MIN_TRAJECTORY_POINTS = 5 // Mínimo de puntos para validar trayectoria&#10;    }&#10;&#10;&#10;    // Variables para rastrear el movimiento de la letra Z&#10;    private val zTrajectoryPoints = mutableListOf&lt;TrajectoryPoint&gt;()&#10;    private var zDetectionStarted = false&#10;&#10;    data class TrajectoryPoint(&#10;        val x: Float,&#10;        val y: Float,&#10;        val timestamp: Long&#10;    )&#10;&#10;    /**&#10;     * Índices de landmarks en MediaPipe Hand Landmarker&#10;     * 0: WRIST (muñeca)&#10;     * 1-4: THUMB (pulgar) - tip: 4&#10;     * 5-8: INDEX (índice) - tip: 8&#10;     * 9-12: MIDDLE (medio) - tip: 12&#10;     * 13-16: RING (anular) - tip: 16&#10;     * 17-20: PINKY (meñique) - tip: 20&#10;     */&#10;&#10;    /**&#10;     * Valida si la seña corresponde a la vocal A&#10;     * Características: Pulgar extendido hacia afuera, demás dedos cerrados formando puño&#10;     */&#10;    fun validateLetterA(handResult: HandLandmarkerResult): Boolean {&#10;        if (handResult.landmarks().isEmpty()) return false&#10;&#10;        val landmarks = handResult.landmarks()[0] // Primera mano detectada&#10;&#10;        try {&#10;            // Verificar que el pulgar esté extendido&#10;            val isThumbExtended = isThumbExtended(landmarks)&#10;&#10;            // Verificar que los demás dedos estén cerrados (formando puño)&#10;            val isIndexClosed = !isFingerExtended(landmarks, FingerType.INDEX)&#10;            val isMiddleClosed = !isFingerExtended(landmarks, FingerType.MIDDLE)&#10;            val isRingClosed = !isFingerExtended(landmarks, FingerType.RING)&#10;            val isPinkyClosed = !isFingerExtended(landmarks, FingerType.PINKY)&#10;&#10;            return isThumbExtended &amp;&amp; isIndexClosed &amp;&amp; isMiddleClosed &amp;&amp; isRingClosed &amp;&amp; isPinkyClosed&#10;        } catch (e: Exception) {&#10;            return false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Valida si la seña corresponde a la vocal E&#10;     * Características: Todos los dedos curvados/flexionados hacia la palma, pulgar cubriendo puntas&#10;     */&#10;    fun validateLetterE(handResult: HandLandmarkerResult): Boolean {&#10;        if (handResult.landmarks().isEmpty()) return false&#10;&#10;        val landmarks = handResult.landmarks()[0]&#10;&#10;        try {&#10;            // Verificar que todos los dedos estén flexionados/curvados&#10;            val allFingersCurved = !isFingerExtended(landmarks, FingerType.INDEX) &amp;&amp;&#10;                                 !isFingerExtended(landmarks, FingerType.MIDDLE) &amp;&amp;&#10;                                 !isFingerExtended(landmarks, FingerType.RING) &amp;&amp;&#10;                                 !isFingerExtended(landmarks, FingerType.PINKY)&#10;&#10;            // Verificar que el pulgar esté posicionado sobre los demás dedos&#10;            val thumbPosition = isThumbCoveringFingers(landmarks)&#10;&#10;            return allFingersCurved &amp;&amp; thumbPosition&#10;        } catch (e: Exception) {&#10;            return false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Valida si la seña corresponde a la vocal I&#10;     * Características: Solo meñique extendido hacia arriba, demás dedos cerrados&#10;     */&#10;    fun validateLetterI(handResult: HandLandmarkerResult): Boolean {&#10;        if (handResult.landmarks().isEmpty()) return false&#10;&#10;        val landmarks = handResult.landmarks()[0]&#10;&#10;        try {&#10;            // Verificar que solo el meñique esté extendido&#10;            val isPinkyExtended = isFingerExtended(landmarks, FingerType.PINKY)&#10;            val isThumbClosed = !isThumbExtended(landmarks)&#10;            val isIndexClosed = !isFingerExtended(landmarks, FingerType.INDEX)&#10;            val isMiddleClosed = !isFingerExtended(landmarks, FingerType.MIDDLE)&#10;            val isRingClosed = !isFingerExtended(landmarks, FingerType.RING)&#10;&#10;            return isPinkyExtended &amp;&amp; isThumbClosed &amp;&amp; isIndexClosed &amp;&amp; isMiddleClosed &amp;&amp; isRingClosed&#10;        } catch (e: Exception) {&#10;            return false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Valida si la seña corresponde a la vocal O&#10;     * Características: Todos los dedos curvados formando un círculo/óvalo&#10;     */&#10;    fun validateLetterO(handResult: HandLandmarkerResult): Boolean {&#10;        if (handResult.landmarks().isEmpty()) return false&#10;&#10;        val landmarks = handResult.landmarks()[0]&#10;&#10;        try {&#10;            // Verificar que los dedos formen una forma circular&#10;            // El pulgar debe tocar aproximadamente las puntas de los demás dedos&#10;            val fingertipsClose = areFingertipsFormingCircle(landmarks)&#10;&#10;            // Los dedos no deben estar completamente extendidos ni completamente cerrados&#10;            val fingersPartiallyExtended = areFingersCurvedForO(landmarks)&#10;&#10;            return fingertipsClose &amp;&amp; fingersPartiallyExtended&#10;        } catch (e: Exception) {&#10;            return false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Valida si la seña corresponde a la vocal U&#10;     * Características: Índice y meñique extendidos hacia arriba, medio, anular y pulgar cerrados&#10;     */&#10;    fun validateLetterU(handResult: HandLandmarkerResult): Boolean {&#10;        if (handResult.landmarks().isEmpty()) return false&#10;&#10;        val landmarks = handResult.landmarks()[0]&#10;&#10;        try {&#10;            // Verificar que índice y meñique estén extendidos&#10;            val isIndexExtended = isFingerExtended(landmarks, FingerType.INDEX)&#10;            val isPinkyExtended = isFingerExtended(landmarks, FingerType.PINKY)&#10;&#10;            // Verificar que demás dedos estén cerrados&#10;            val isThumbClosed = !isThumbExtended(landmarks)&#10;            val isMiddleClosed = !isFingerExtended(landmarks, FingerType.MIDDLE)&#10;            val isRingClosed = !isFingerExtended(landmarks, FingerType.RING)&#10;&#10;            return isIndexExtended &amp;&amp; isPinkyExtended &amp;&amp;&#10;                   isThumbClosed &amp;&amp; isMiddleClosed &amp;&amp; isRingClosed&#10;        } catch (e: Exception) {&#10;            return false&#10;        }&#10;    }&#10;&#10;&#10;    /**&#10;     * Valida si la seña corresponde a la letra Z&#10;     * Características: Solo índice extendido, mano se mueve trazando una Z&#10;     * Requiere detección de movimiento continuo formando una Z&#10;     */&#10;    fun validateLetterZ(handResult: HandLandmarkerResult): LetterZValidationResult {&#10;        if (handResult.landmarks().isEmpty()) {&#10;            resetZTrajectory()&#10;            return LetterZValidationResult(false, &quot;No se detecta mano&quot;, 0f)&#10;        }&#10;&#10;        val landmarks = handResult.landmarks()[0]&#10;&#10;        try {&#10;            // 1. Verificar que solo el índice esté extendido (posición de Z)&#10;            val isIndexExtended = isFingerExtended(landmarks, FingerType.INDEX)&#10;            val isThumbClosed = !isThumbExtended(landmarks)&#10;            val isMiddleClosed = !isFingerExtended(landmarks, FingerType.MIDDLE)&#10;            val isRingClosed = !isFingerExtended(landmarks, FingerType.RING)&#10;            val isPinkyClosed = !isFingerExtended(landmarks, FingerType.PINKY)&#10;&#10;            val correctHandShape = isIndexExtended &amp;&amp; isThumbClosed &amp;&amp;&#10;                                  isMiddleClosed &amp;&amp; isRingClosed &amp;&amp; isPinkyClosed&#10;&#10;            if (!correctHandShape) {&#10;                resetZTrajectory()&#10;                return LetterZValidationResult(false, &quot;Forma de mano incorrecta - solo índice extendido&quot;, 0f)&#10;            }&#10;&#10;            // 2. Rastrear el movimiento del índice&#10;            val indexTip = landmarks[8] // Punta del índice&#10;            val currentTime = System.currentTimeMillis()&#10;&#10;            // Añadir punto a la trayectoria&#10;            zTrajectoryPoints.add(TrajectoryPoint(indexTip.x(), indexTip.y(), currentTime))&#10;&#10;            // Limpiar puntos antiguos (más de 3 segundos para dar tiempo de trazar la Z)&#10;            zTrajectoryPoints.removeAll { currentTime - it.timestamp &gt; 3000 }&#10;&#10;            // 3. Verificar si la trayectoria forma una Z&#10;            if (zTrajectoryPoints.size &gt;= MIN_TRAJECTORY_POINTS * 2) { // Necesitamos más puntos para una Z&#10;                val zResult = detectZMovement(zTrajectoryPoints)&#10;&#10;                if (zResult.isZ) {&#10;                    val confidence = zResult.confidence&#10;                    return LetterZValidationResult(true, &quot;¡Z completada!&quot;, confidence)&#10;                }&#10;&#10;                return LetterZValidationResult(false, &quot;Traza una Z: línea horizontal → diagonal → línea horizontal&quot;, zResult.confidence)&#10;            }&#10;&#10;            return LetterZValidationResult(false, &quot;Mantén la posición y traza una Z con tu dedo&quot;, 0.3f)&#10;&#10;        } catch (e: Exception) {&#10;            resetZTrajectory()&#10;            return LetterZValidationResult(false, &quot;Error en validación&quot;, 0f)&#10;        }&#10;    }&#10;&#10;&#10;    /**&#10;     * Detecta si el conjunto de puntos forma una Z&#10;     * Una Z consiste en: línea horizontal superior → diagonal descendente → línea horizontal inferior&#10;     */&#10;    private fun detectZMovement(points: List&lt;TrajectoryPoint&gt;): ZDetectionResult {&#10;        if (points.size &lt; MIN_TRAJECTORY_POINTS * 2) {&#10;            return ZDetectionResult(false, 0f)&#10;        }&#10;&#10;        // Dividir la trayectoria en tres segmentos&#10;        val segmentSize = points.size / 3&#10;        if (segmentSize &lt; 2) {&#10;            return ZDetectionResult(false, 0.1f)&#10;        }&#10;&#10;        val segment1 = points.subList(0, segmentSize) // Línea horizontal superior&#10;        val segment2 = points.subList(segmentSize, segmentSize * 2) // Diagonal&#10;        val segment3 = points.subList(segmentSize * 2, points.size) // Línea horizontal inferior&#10;&#10;        // Verificar características de cada segmento&#10;        val horizontalTop = isHorizontalMovement(segment1)&#10;        val diagonal = isDiagonalMovement(segment2)&#10;        val horizontalBottom = isHorizontalMovement(segment3)&#10;&#10;        // Verificar dirección general: de arriba-izquierda a abajo-derecha&#10;        val overallDirection = checkZDirection(points.first(), points.last())&#10;&#10;        // Calcular confianza&#10;        var confidence = 0f&#10;        if (horizontalTop) confidence += 0.3f&#10;        if (diagonal) confidence += 0.3f&#10;        if (horizontalBottom) confidence += 0.3f&#10;        if (overallDirection) confidence += 0.1f&#10;&#10;        val isZ = confidence &gt;= 0.7f&#10;&#10;        return ZDetectionResult(isZ, confidence)&#10;    }&#10;&#10;    /**&#10;     * Verifica si un segmento de puntos representa un movimiento horizontal&#10;     */&#10;    private fun isHorizontalMovement(segment: List&lt;TrajectoryPoint&gt;): Boolean {&#10;        if (segment.size &lt; 2) return false&#10;&#10;        val start = segment.first()&#10;        val end = segment.last()&#10;&#10;        // Movimiento horizontal: cambio en X mayor que cambio en Y&#10;        val deltaX = abs(end.x - start.x)&#10;        val deltaY = abs(end.y - start.y)&#10;&#10;        return deltaX &gt; deltaY &amp;&amp; deltaX &gt; 0.05f&#10;    }&#10;&#10;    /**&#10;     * Verifica si un segmento de puntos representa un movimiento diagonal&#10;     */&#10;    private fun isDiagonalMovement(segment: List&lt;TrajectoryPoint&gt;): Boolean {&#10;        if (segment.size &lt; 2) return false&#10;&#10;        val start = segment.first()&#10;        val end = segment.last()&#10;&#10;        val deltaX = abs(end.x - start.x)&#10;        val deltaY = abs(end.y - start.y)&#10;&#10;        // Movimiento diagonal: cambios en X e Y similares&#10;        val ratio = if (deltaX &gt; deltaY) deltaY / deltaX else deltaX / deltaY&#10;&#10;        return ratio &gt; 0.5f &amp;&amp; (deltaX &gt; 0.05f || deltaY &gt; 0.05f)&#10;    }&#10;&#10;    /**&#10;     * Verifica la dirección general de la Z (debe ir de izquierda-arriba a derecha-abajo en cámara frontal)&#10;     */&#10;    private fun checkZDirection(start: TrajectoryPoint, end: TrajectoryPoint): Boolean {&#10;        // En cámara frontal, Y aumenta hacia abajo, X aumenta hacia la derecha&#10;        // Para una Z típica, el punto final debe estar más abajo que el inicial&#10;        return end.y &gt; start.y&#10;    }&#10;&#10;    /**&#10;     * Resetea el rastreo de trayectoria para la letra Z&#10;     */&#10;    fun resetZTrajectory() {&#10;        zTrajectoryPoints.clear()&#10;        zDetectionStarted = false&#10;    }&#10;&#10;    /**&#10;     * Valida si la seña corresponde a &quot;Amigo&quot;&#10;     * Características SIMPLIFICADAS: Una mano arriba y otra abajo, cerca una de la otra&#10;     */&#10;    fun validateSignAmigo(handResult: HandLandmarkerResult): SignAmigoValidationResult {&#10;        // Verificar que se detecten exactamente DOS manos&#10;        if (handResult.landmarks().size != 2) {&#10;            return SignAmigoValidationResult(&#10;                false,&#10;                if (handResult.landmarks().isEmpty()) {&#10;                    &quot;Muestra ambas manos a la cámara&quot;&#10;                } else {&#10;                    &quot;Muestra AMBAS manos para la seña de 'Amigo'&quot;&#10;                },&#10;                0f&#10;            )&#10;        }&#10;&#10;        try {&#10;            val hand1 = handResult.landmarks()[0]&#10;            val hand2 = handResult.landmarks()[1]&#10;&#10;            // Obtener las muñecas de ambas manos&#10;            val wrist1 = hand1[0]&#10;            val wrist2 = hand2[0]&#10;&#10;            // 1. SOLO verificar que una mano esté arriba y otra abajo (diferencia en Y)&#10;            val verticalDistance = abs(wrist1.y() - wrist2.y())&#10;            val oneAboveOther = verticalDistance &gt; 0.03f // Mínima diferencia de altura&#10;&#10;            if (!oneAboveOther) {&#10;                return SignAmigoValidationResult(&#10;                    false,&#10;                    &quot;Coloca una mano arriba y otra abajo&quot;,&#10;                    0.3f&#10;                )&#10;            }&#10;&#10;            // 2. SOLO verificar que las manos estén CERCA horizontalmente (aproximadamente alineadas)&#10;            val horizontalDistance = abs(wrist1.x() - wrist2.x())&#10;            val areClose = horizontalDistance &lt; 0.25f // MUY permisivo&#10;&#10;            if (!areClose) {&#10;                return SignAmigoValidationResult(&#10;                    false,&#10;                    &quot;Acerca más las manos&quot;,&#10;                    0.6f&#10;                )&#10;            }&#10;&#10;            // ¡Eso es todo! Si llegó aquí, la seña es válida&#10;            return SignAmigoValidationResult(&#10;                true,&#10;                &quot;¡Perfecto! Seña de 'Amigo' completada&quot;,&#10;                1.0f&#10;            )&#10;&#10;        } catch (e: Exception) {&#10;            return SignAmigoValidationResult(&#10;                false,&#10;                &quot;Error en la validación&quot;,&#10;                0f&#10;            )&#10;        }&#10;    }&#10;&#10;    data class SignAmigoValidationResult(&#10;        val isValid: Boolean,&#10;        val message: String,&#10;        val confidence: Float&#10;    )&#10;&#10;    // Clases de datos para resultados&#10;    data class LetterZValidationResult(&#10;        val isValid: Boolean,&#10;        val message: String,&#10;        val confidence: Float&#10;    )&#10;&#10;    private data class ZDetectionResult(&#10;        val isZ: Boolean,&#10;        val confidence: Float&#10;    )&#10;&#10;    // Funciones auxiliares para análisis de landmarks&#10;&#10;    private enum class FingerType(val tipIndex: Int, val pipIndex: Int, val mcpIndex: Int) {&#10;        INDEX(8, 7, 5),&#10;        MIDDLE(12, 11, 9),&#10;        RING(16, 15, 13),&#10;        PINKY(20, 19, 17)&#10;    }&#10;&#10;    /**&#10;     * Determina si un dedo específico está extendido&#10;     */&#10;    private fun isFingerExtended(landmarks: List&lt;com.google.mediapipe.tasks.components.containers.NormalizedLandmark&gt;, finger: FingerType): Boolean {&#10;        val tipY = landmarks[finger.tipIndex].y()&#10;        val pipY = landmarks[finger.pipIndex].y()&#10;        val mcpY = landmarks[finger.mcpIndex].y()&#10;&#10;        // Un dedo está extendido si la punta está más arriba que las articulaciones&#10;        return tipY &lt; pipY &amp;&amp; pipY &lt; mcpY&#10;    }&#10;&#10;    /**&#10;     * Determina si el pulgar está extendido&#10;     */&#10;    private fun isThumbExtended(landmarks: List&lt;com.google.mediapipe.tasks.components.containers.NormalizedLandmark&gt;): Boolean {&#10;        val thumbTip = landmarks[4]&#10;        val thumbMcp = landmarks[2]&#10;        val wrist = landmarks[0]&#10;&#10;        // Calcular la distancia del pulgar desde la muñeca&#10;        val tipDistance = distance(thumbTip.x(), thumbTip.y(), wrist.x(), wrist.y())&#10;        val mcpDistance = distance(thumbMcp.x(), thumbMcp.y(), wrist.x(), wrist.y())&#10;&#10;        return tipDistance &gt; mcpDistance * 1.2f&#10;    }&#10;&#10;    /**&#10;     * Verifica si el pulgar está cubriendo las puntas de los dedos (para letra E)&#10;     */&#10;    private fun isThumbCoveringFingers(landmarks: List&lt;com.google.mediapipe.tasks.components.containers.NormalizedLandmark&gt;): Boolean {&#10;        val thumbTip = landmarks[4]&#10;        val indexTip = landmarks[8]&#10;        val middleTip = landmarks[12]&#10;&#10;        // El pulgar debe estar cerca de las puntas de los otros dedos&#10;        val distToIndex = distance(thumbTip.x(), thumbTip.y(), indexTip.x(), indexTip.y())&#10;        val distToMiddle = distance(thumbTip.x(), thumbTip.y(), middleTip.x(), middleTip.y())&#10;&#10;        return distToIndex &lt; 0.05f || distToMiddle &lt; 0.05f&#10;    }&#10;&#10;    /**&#10;     * Verifica si las puntas de los dedos forman un círculo (para letra O)&#10;     */&#10;    private fun areFingertipsFormingCircle(landmarks: List&lt;com.google.mediapipe.tasks.components.containers.NormalizedLandmark&gt;): Boolean {&#10;        val thumbTip = landmarks[4]&#10;        val indexTip = landmarks[8]&#10;        val middleTip = landmarks[12]&#10;&#10;        // Las puntas deben estar relativamente cerca entre sí&#10;        val thumbIndexDist = distance(thumbTip.x(), thumbTip.y(), indexTip.x(), indexTip.y())&#10;        val thumbMiddleDist = distance(thumbTip.x(), thumbTip.y(), middleTip.x(), middleTip.y())&#10;&#10;        return thumbIndexDist &lt; 0.08f &amp;&amp; thumbMiddleDist &lt; 0.1f&#10;    }&#10;&#10;    /**&#10;     * Verifica si los dedos están curvados apropiadamente para la letra O&#10;     */&#10;    private fun areFingersCurvedForO(landmarks: List&lt;com.google.mediapipe.tasks.components.containers.NormalizedLandmark&gt;): Boolean {&#10;        // Los dedos no deben estar completamente extendidos&#10;        val indexExtended = isFingerExtended(landmarks, FingerType.INDEX)&#10;        val middleExtended = isFingerExtended(landmarks, FingerType.MIDDLE)&#10;&#10;        return !indexExtended &amp;&amp; !middleExtended&#10;    }&#10;&#10;&#10;    /**&#10;     * Calcula la distancia euclidiana entre dos puntos&#10;     */&#10;    private fun distance(x1: Float, y1: Float, x2: Float, y2: Float): Float {&#10;        return sqrt((x2 - x1).pow(2) + (y2 - y1).pow(2))&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.ecohand.ml&#10;&#10;import com.google.mediapipe.tasks.vision.handlandmarker.HandLandmarkerResult&#10;import kotlin.math.*&#10;&#10;/**&#10; * Validador de señas para vocales en lenguaje de señas&#10; * Analiza landmarks de MediaPipe para determinar si una seña es correcta&#10; */&#10;class VowelSignValidator {&#10;&#10;    companion object {&#10;        private const val FINGER_THRESHOLD = 0.1f // Umbral para determinar si un dedo está extendido&#10;        private const val ANGLE_THRESHOLD = 30f // Umbral para ángulos en grados&#10;        private const val MOVEMENT_THRESHOLD = 0.15f // Umbral mínimo de movimiento para detectar el arco&#10;        private const val MIN_TRAJECTORY_POINTS = 5 // Mínimo de puntos para validar trayectoria&#10;    }&#10;&#10;&#10;    // Variables para rastrear el movimiento de la letra Z&#10;    private val zTrajectoryPoints = mutableListOf&lt;TrajectoryPoint&gt;()&#10;    private var zDetectionStarted = false&#10;&#10;    data class TrajectoryPoint(&#10;        val x: Float,&#10;        val y: Float,&#10;        val timestamp: Long&#10;    )&#10;&#10;    /**&#10;     * Índices de landmarks en MediaPipe Hand Landmarker&#10;     * 0: WRIST (muñeca)&#10;     * 1-4: THUMB (pulgar) - tip: 4&#10;     * 5-8: INDEX (índice) - tip: 8&#10;     * 9-12: MIDDLE (medio) - tip: 12&#10;     * 13-16: RING (anular) - tip: 16&#10;     * 17-20: PINKY (meñique) - tip: 20&#10;     */&#10;&#10;    /**&#10;     * Valida si la seña corresponde a la vocal A&#10;     * Características: Pulgar extendido hacia afuera, demás dedos cerrados formando puño&#10;     */&#10;    fun validateLetterA(handResult: HandLandmarkerResult): Boolean {&#10;        if (handResult.landmarks().isEmpty()) return false&#10;&#10;        val landmarks = handResult.landmarks()[0] // Primera mano detectada&#10;&#10;        try {&#10;            // Verificar que el pulgar esté extendido&#10;            val isThumbExtended = isThumbExtended(landmarks)&#10;&#10;            // Verificar que los demás dedos estén cerrados (formando puño)&#10;            val isIndexClosed = !isFingerExtended(landmarks, FingerType.INDEX)&#10;            val isMiddleClosed = !isFingerExtended(landmarks, FingerType.MIDDLE)&#10;            val isRingClosed = !isFingerExtended(landmarks, FingerType.RING)&#10;            val isPinkyClosed = !isFingerExtended(landmarks, FingerType.PINKY)&#10;&#10;            return isThumbExtended &amp;&amp; isIndexClosed &amp;&amp; isMiddleClosed &amp;&amp; isRingClosed &amp;&amp; isPinkyClosed&#10;        } catch (e: Exception) {&#10;            return false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Valida si la seña corresponde a la vocal E&#10;     * Características: Todos los dedos curvados/flexionados hacia la palma, pulgar cubriendo puntas&#10;     */&#10;    fun validateLetterE(handResult: HandLandmarkerResult): Boolean {&#10;        if (handResult.landmarks().isEmpty()) return false&#10;&#10;        val landmarks = handResult.landmarks()[0]&#10;&#10;        try {&#10;            // Verificar que todos los dedos estén flexionados/curvados&#10;            val allFingersCurved = !isFingerExtended(landmarks, FingerType.INDEX) &amp;&amp;&#10;                                 !isFingerExtended(landmarks, FingerType.MIDDLE) &amp;&amp;&#10;                                 !isFingerExtended(landmarks, FingerType.RING) &amp;&amp;&#10;                                 !isFingerExtended(landmarks, FingerType.PINKY)&#10;&#10;            // Verificar que el pulgar esté posicionado sobre los demás dedos&#10;            val thumbPosition = isThumbCoveringFingers(landmarks)&#10;&#10;            return allFingersCurved &amp;&amp; thumbPosition&#10;        } catch (e: Exception) {&#10;            return false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Valida si la seña corresponde a la vocal I&#10;     * Características: Solo meñique extendido hacia arriba, demás dedos cerrados&#10;     */&#10;    fun validateLetterI(handResult: HandLandmarkerResult): Boolean {&#10;        if (handResult.landmarks().isEmpty()) return false&#10;&#10;        val landmarks = handResult.landmarks()[0]&#10;&#10;        try {&#10;            // Verificar que solo el meñique esté extendido&#10;            val isPinkyExtended = isFingerExtended(landmarks, FingerType.PINKY)&#10;            val isThumbClosed = !isThumbExtended(landmarks)&#10;            val isIndexClosed = !isFingerExtended(landmarks, FingerType.INDEX)&#10;            val isMiddleClosed = !isFingerExtended(landmarks, FingerType.MIDDLE)&#10;            val isRingClosed = !isFingerExtended(landmarks, FingerType.RING)&#10;&#10;            return isPinkyExtended &amp;&amp; isThumbClosed &amp;&amp; isIndexClosed &amp;&amp; isMiddleClosed &amp;&amp; isRingClosed&#10;        } catch (e: Exception) {&#10;            return false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Valida si la seña corresponde a la vocal O&#10;     * Características: Todos los dedos curvados formando un círculo/óvalo&#10;     */&#10;    fun validateLetterO(handResult: HandLandmarkerResult): Boolean {&#10;        if (handResult.landmarks().isEmpty()) return false&#10;&#10;        val landmarks = handResult.landmarks()[0]&#10;&#10;        try {&#10;            // Verificar que los dedos formen una forma circular&#10;            // El pulgar debe tocar aproximadamente las puntas de los demás dedos&#10;            val fingertipsClose = areFingertipsFormingCircle(landmarks)&#10;&#10;            // Los dedos no deben estar completamente extendidos ni completamente cerrados&#10;            val fingersPartiallyExtended = areFingersCurvedForO(landmarks)&#10;&#10;            return fingertipsClose &amp;&amp; fingersPartiallyExtended&#10;        } catch (e: Exception) {&#10;            return false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Valida si la seña corresponde a la vocal U&#10;     * Características: Índice y meñique extendidos hacia arriba, medio, anular y pulgar cerrados&#10;     */&#10;    fun validateLetterU(handResult: HandLandmarkerResult): Boolean {&#10;        if (handResult.landmarks().isEmpty()) return false&#10;&#10;        val landmarks = handResult.landmarks()[0]&#10;&#10;        try {&#10;            // Verificar que índice y meñique estén extendidos&#10;            val isIndexExtended = isFingerExtended(landmarks, FingerType.INDEX)&#10;            val isPinkyExtended = isFingerExtended(landmarks, FingerType.PINKY)&#10;&#10;            // Verificar que demás dedos estén cerrados&#10;            val isThumbClosed = !isThumbExtended(landmarks)&#10;            val isMiddleClosed = !isFingerExtended(landmarks, FingerType.MIDDLE)&#10;            val isRingClosed = !isFingerExtended(landmarks, FingerType.RING)&#10;&#10;            return isIndexExtended &amp;&amp; isPinkyExtended &amp;&amp;&#10;                   isThumbClosed &amp;&amp; isMiddleClosed &amp;&amp; isRingClosed&#10;        } catch (e: Exception) {&#10;            return false&#10;        }&#10;    }&#10;&#10;&#10;    /**&#10;     * Valida si la seña corresponde a la letra Z&#10;     * Características: Solo índice extendido, mano se mueve trazando una Z&#10;     * Requiere detección de movimiento continuo formando una Z&#10;     */&#10;    fun validateLetterZ(handResult: HandLandmarkerResult): LetterZValidationResult {&#10;        if (handResult.landmarks().isEmpty()) {&#10;            resetZTrajectory()&#10;            return LetterZValidationResult(false, &quot;No se detecta mano&quot;, 0f)&#10;        }&#10;&#10;        val landmarks = handResult.landmarks()[0]&#10;&#10;        try {&#10;            // 1. Verificar que solo el índice esté extendido (posición de Z)&#10;            val isIndexExtended = isFingerExtended(landmarks, FingerType.INDEX)&#10;            val isThumbClosed = !isThumbExtended(landmarks)&#10;            val isMiddleClosed = !isFingerExtended(landmarks, FingerType.MIDDLE)&#10;            val isRingClosed = !isFingerExtended(landmarks, FingerType.RING)&#10;            val isPinkyClosed = !isFingerExtended(landmarks, FingerType.PINKY)&#10;&#10;            val correctHandShape = isIndexExtended &amp;&amp; isThumbClosed &amp;&amp;&#10;                                  isMiddleClosed &amp;&amp; isRingClosed &amp;&amp; isPinkyClosed&#10;&#10;            if (!correctHandShape) {&#10;                resetZTrajectory()&#10;                return LetterZValidationResult(false, &quot;Forma de mano incorrecta - solo índice extendido&quot;, 0f)&#10;            }&#10;&#10;            // 2. Rastrear el movimiento del índice&#10;            val indexTip = landmarks[8] // Punta del índice&#10;            val currentTime = System.currentTimeMillis()&#10;&#10;            // Añadir punto a la trayectoria&#10;            zTrajectoryPoints.add(TrajectoryPoint(indexTip.x(), indexTip.y(), currentTime))&#10;&#10;            // Limpiar puntos antiguos (más de 3 segundos para dar tiempo de trazar la Z)&#10;            zTrajectoryPoints.removeAll { currentTime - it.timestamp &gt; 3000 }&#10;&#10;            // 3. Verificar si la trayectoria forma una Z&#10;            if (zTrajectoryPoints.size &gt;= MIN_TRAJECTORY_POINTS * 2) { // Necesitamos más puntos para una Z&#10;                val zResult = detectZMovement(zTrajectoryPoints)&#10;&#10;                if (zResult.isZ) {&#10;                    val confidence = zResult.confidence&#10;                    return LetterZValidationResult(true, &quot;¡Z completada!&quot;, confidence)&#10;                }&#10;&#10;                return LetterZValidationResult(false, &quot;Traza una Z: línea horizontal → diagonal → línea horizontal&quot;, zResult.confidence)&#10;            }&#10;&#10;            return LetterZValidationResult(false, &quot;Mantén la posición y traza una Z con tu dedo&quot;, 0.3f)&#10;&#10;        } catch (e: Exception) {&#10;            resetZTrajectory()&#10;            return LetterZValidationResult(false, &quot;Error en validación&quot;, 0f)&#10;        }&#10;    }&#10;&#10;&#10;    /**&#10;     * Detecta si el conjunto de puntos forma una Z&#10;     * Una Z consiste en: línea horizontal superior → diagonal descendente → línea horizontal inferior&#10;     */&#10;    private fun detectZMovement(points: List&lt;TrajectoryPoint&gt;): ZDetectionResult {&#10;        if (points.size &lt; MIN_TRAJECTORY_POINTS * 2) {&#10;            return ZDetectionResult(false, 0f)&#10;        }&#10;&#10;        // Dividir la trayectoria en tres segmentos&#10;        val segmentSize = points.size / 3&#10;        if (segmentSize &lt; 2) {&#10;            return ZDetectionResult(false, 0.1f)&#10;        }&#10;&#10;        val segment1 = points.subList(0, segmentSize) // Línea horizontal superior&#10;        val segment2 = points.subList(segmentSize, segmentSize * 2) // Diagonal&#10;        val segment3 = points.subList(segmentSize * 2, points.size) // Línea horizontal inferior&#10;&#10;        // Verificar características de cada segmento&#10;        val horizontalTop = isHorizontalMovement(segment1)&#10;        val diagonal = isDiagonalMovement(segment2)&#10;        val horizontalBottom = isHorizontalMovement(segment3)&#10;&#10;        // Verificar dirección general: de arriba-izquierda a abajo-derecha&#10;        val overallDirection = checkZDirection(points.first(), points.last())&#10;&#10;        // Calcular confianza&#10;        var confidence = 0f&#10;        if (horizontalTop) confidence += 0.3f&#10;        if (diagonal) confidence += 0.3f&#10;        if (horizontalBottom) confidence += 0.3f&#10;        if (overallDirection) confidence += 0.1f&#10;&#10;        val isZ = confidence &gt;= 0.7f&#10;&#10;        return ZDetectionResult(isZ, confidence)&#10;    }&#10;&#10;    /**&#10;     * Verifica si un segmento de puntos representa un movimiento horizontal&#10;     */&#10;    private fun isHorizontalMovement(segment: List&lt;TrajectoryPoint&gt;): Boolean {&#10;        if (segment.size &lt; 2) return false&#10;&#10;        val start = segment.first()&#10;        val end = segment.last()&#10;&#10;        // Movimiento horizontal: cambio en X mayor que cambio en Y&#10;        val deltaX = abs(end.x - start.x)&#10;        val deltaY = abs(end.y - start.y)&#10;&#10;        return deltaX &gt; deltaY &amp;&amp; deltaX &gt; 0.05f&#10;    }&#10;&#10;    /**&#10;     * Verifica si un segmento de puntos representa un movimiento diagonal&#10;     */&#10;    private fun isDiagonalMovement(segment: List&lt;TrajectoryPoint&gt;): Boolean {&#10;        if (segment.size &lt; 2) return false&#10;&#10;        val start = segment.first()&#10;        val end = segment.last()&#10;&#10;        val deltaX = abs(end.x - start.x)&#10;        val deltaY = abs(end.y - start.y)&#10;&#10;        // Movimiento diagonal: cambios en X e Y similares&#10;        val ratio = if (deltaX &gt; deltaY) deltaY / deltaX else deltaX / deltaY&#10;&#10;        return ratio &gt; 0.5f &amp;&amp; (deltaX &gt; 0.05f || deltaY &gt; 0.05f)&#10;    }&#10;&#10;    /**&#10;     * Verifica la dirección general de la Z (debe ir de izquierda-arriba a derecha-abajo en cámara frontal)&#10;     */&#10;    private fun checkZDirection(start: TrajectoryPoint, end: TrajectoryPoint): Boolean {&#10;        // En cámara frontal, Y aumenta hacia abajo, X aumenta hacia la derecha&#10;        // Para una Z típica, el punto final debe estar más abajo que el inicial&#10;        return end.y &gt; start.y&#10;    }&#10;&#10;    /**&#10;     * Resetea el rastreo de trayectoria para la letra Z&#10;     */&#10;    fun resetZTrajectory() {&#10;        zTrajectoryPoints.clear()&#10;        zDetectionStarted = false&#10;    }&#10;&#10;    /**&#10;     * Valida si la seña corresponde al número 0 (CERO)&#10;     * Características: Todos los dedos extendidos pero curvados formando un círculo/óvalo,&#10;     * con las puntas de los dedos tocando la punta del pulgar (similar a la letra O)&#10;     */&#10;    fun validateNumber0(handResult: HandLandmarkerResult): Boolean {&#10;        if (handResult.landmarks().isEmpty()) return false&#10;&#10;        val landmarks = handResult.landmarks()[0]&#10;&#10;        try {&#10;            // Verificar que los dedos formen una forma circular&#10;            // El pulgar debe tocar aproximadamente las puntas de los demás dedos&#10;            val fingertipsClose = areFingertipsFormingCircle(landmarks)&#10;&#10;            // Los dedos no deben estar completamente extendidos ni completamente cerrados&#10;            val fingersPartiallyExtended = areFingersCurvedForO(landmarks)&#10;&#10;            return fingertipsClose &amp;&amp; fingersPartiallyExtended&#10;        } catch (e: Exception) {&#10;            return false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Valida si la seña corresponde al número 1 (UNO)&#10;     * Características: Solo el dedo índice extendido hacia arriba, demás dedos cerrados&#10;     */&#10;    fun validateNumber1(handResult: HandLandmarkerResult): Boolean {&#10;        if (handResult.landmarks().isEmpty()) return false&#10;&#10;        val landmarks = handResult.landmarks()[0]&#10;&#10;        try {&#10;            // Verificar que solo el índice esté extendido&#10;            val isIndexExtended = isFingerExtended(landmarks, FingerType.INDEX)&#10;            val isThumbClosed = !isThumbExtended(landmarks)&#10;            val isMiddleClosed = !isFingerExtended(landmarks, FingerType.MIDDLE)&#10;            val isRingClosed = !isFingerExtended(landmarks, FingerType.RING)&#10;            val isPinkyClosed = !isFingerExtended(landmarks, FingerType.PINKY)&#10;&#10;            return isIndexExtended &amp;&amp; isThumbClosed &amp;&amp; isMiddleClosed &amp;&amp; isRingClosed &amp;&amp; isPinkyClosed&#10;        } catch (e: Exception) {&#10;            return false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Valida si la seña corresponde al número 2 (DOS)&#10;     * Características: Dedos índice y medio extendidos hacia arriba formando una V&#10;     */&#10;    fun validateNumber2(handResult: HandLandmarkerResult): Boolean {&#10;        if (handResult.landmarks().isEmpty()) return false&#10;&#10;        val landmarks = handResult.landmarks()[0]&#10;&#10;        try {&#10;            // Verificar que índice y medio estén extendidos&#10;            val isIndexExtended = isFingerExtended(landmarks, FingerType.INDEX)&#10;            val isMiddleExtended = isFingerExtended(landmarks, FingerType.MIDDLE)&#10;&#10;            // Verificar que los demás dedos estén cerrados&#10;            val isThumbClosed = !isThumbExtended(landmarks)&#10;            val isRingClosed = !isFingerExtended(landmarks, FingerType.RING)&#10;            val isPinkyClosed = !isFingerExtended(landmarks, FingerType.PINKY)&#10;&#10;            return isIndexExtended &amp;&amp; isMiddleExtended &amp;&amp;&#10;                   isThumbClosed &amp;&amp; isRingClosed &amp;&amp; isPinkyClosed&#10;        } catch (e: Exception) {&#10;            return false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Valida si la seña corresponde al número 3 (TRES)&#10;     * Características: Dedos índice, medio y anular extendidos hacia arriba&#10;     */&#10;    fun validateNumber3(handResult: HandLandmarkerResult): Boolean {&#10;        if (handResult.landmarks().isEmpty()) return false&#10;&#10;        val landmarks = handResult.landmarks()[0]&#10;&#10;        try {&#10;            // Verificar que índice, medio y anular estén extendidos&#10;            val isIndexExtended = isFingerExtended(landmarks, FingerType.INDEX)&#10;            val isMiddleExtended = isFingerExtended(landmarks, FingerType.MIDDLE)&#10;            val isRingExtended = isFingerExtended(landmarks, FingerType.RING)&#10;&#10;            // Verificar que pulgar y meñique estén cerrados&#10;            val isThumbClosed = !isThumbExtended(landmarks)&#10;            val isPinkyClosed = !isFingerExtended(landmarks, FingerType.PINKY)&#10;&#10;            return isIndexExtended &amp;&amp; isMiddleExtended &amp;&amp; isRingExtended &amp;&amp;&#10;                   isThumbClosed &amp;&amp; isPinkyClosed&#10;        } catch (e: Exception) {&#10;            return false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Valida si la seña corresponde al número 4 (CUATRO)&#10;     * Características: Los cuatro dedos extendidos hacia arriba, pulgar doblado hacia la palma&#10;     */&#10;    fun validateNumber4(handResult: HandLandmarkerResult): Boolean {&#10;        if (handResult.landmarks().isEmpty()) return false&#10;&#10;        val landmarks = handResult.landmarks()[0]&#10;&#10;        try {&#10;            // Verificar que los cuatro dedos (índice, medio, anular, meñique) estén extendidos&#10;            val isIndexExtended = isFingerExtended(landmarks, FingerType.INDEX)&#10;            val isMiddleExtended = isFingerExtended(landmarks, FingerType.MIDDLE)&#10;            val isRingExtended = isFingerExtended(landmarks, FingerType.RING)&#10;            val isPinkyExtended = isFingerExtended(landmarks, FingerType.PINKY)&#10;&#10;            // Verificar que el pulgar esté cerrado/doblado&#10;            val isThumbClosed = !isThumbExtended(landmarks)&#10;&#10;            return isIndexExtended &amp;&amp; isMiddleExtended &amp;&amp; isRingExtended &amp;&amp;&#10;                   isPinkyExtended &amp;&amp; isThumbClosed&#10;        } catch (e: Exception) {&#10;            return false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Valida si la seña corresponde al número 5 (CINCO)&#10;     * Características: Todos los dedos extendidos y separados, mano abierta completa&#10;     */&#10;    fun validateNumber5(handResult: HandLandmarkerResult): Boolean {&#10;        if (handResult.landmarks().isEmpty()) return false&#10;&#10;        val landmarks = handResult.landmarks()[0]&#10;&#10;        try {&#10;            // Verificar que TODOS los dedos estén extendidos&#10;            val isThumbExtended = isThumbExtended(landmarks)&#10;            val isIndexExtended = isFingerExtended(landmarks, FingerType.INDEX)&#10;            val isMiddleExtended = isFingerExtended(landmarks, FingerType.MIDDLE)&#10;            val isRingExtended = isFingerExtended(landmarks, FingerType.RING)&#10;            val isPinkyExtended = isFingerExtended(landmarks, FingerType.PINKY)&#10;&#10;            return isThumbExtended &amp;&amp; isIndexExtended &amp;&amp; isMiddleExtended &amp;&amp;&#10;                   isRingExtended &amp;&amp; isPinkyExtended&#10;        } catch (e: Exception) {&#10;            return false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Valida si la seña corresponde a &quot;Amigo&quot;&#10;     * Características SIMPLIFICADAS: Una mano arriba y otra abajo, cerca una de la otra&#10;     */&#10;    fun validateSignAmigo(handResult: HandLandmarkerResult): SignAmigoValidationResult {&#10;        // Verificar que se detecten exactamente DOS manos&#10;        if (handResult.landmarks().size != 2) {&#10;            return SignAmigoValidationResult(&#10;                false,&#10;                if (handResult.landmarks().isEmpty()) {&#10;                    &quot;Muestra ambas manos a la cámara&quot;&#10;                } else {&#10;                    &quot;Muestra AMBAS manos para la seña de 'Amigo'&quot;&#10;                },&#10;                0f&#10;            )&#10;        }&#10;&#10;        try {&#10;            val hand1 = handResult.landmarks()[0]&#10;            val hand2 = handResult.landmarks()[1]&#10;&#10;            // Obtener las muñecas de ambas manos&#10;            val wrist1 = hand1[0]&#10;            val wrist2 = hand2[0]&#10;&#10;            // 1. SOLO verificar que una mano esté arriba y otra abajo (diferencia en Y)&#10;            val verticalDistance = abs(wrist1.y() - wrist2.y())&#10;            val oneAboveOther = verticalDistance &gt; 0.03f // Mínima diferencia de altura&#10;&#10;            if (!oneAboveOther) {&#10;                return SignAmigoValidationResult(&#10;                    false,&#10;                    &quot;Coloca una mano arriba y otra abajo&quot;,&#10;                    0.3f&#10;                )&#10;            }&#10;&#10;            // 2. SOLO verificar que las manos estén CERCA horizontalmente (aproximadamente alineadas)&#10;            val horizontalDistance = abs(wrist1.x() - wrist2.x())&#10;            val areClose = horizontalDistance &lt; 0.25f // MUY permisivo&#10;&#10;            if (!areClose) {&#10;                return SignAmigoValidationResult(&#10;                    false,&#10;                    &quot;Acerca más las manos&quot;,&#10;                    0.6f&#10;                )&#10;            }&#10;&#10;            // ¡Eso es todo! Si llegó aquí, la seña es válida&#10;            return SignAmigoValidationResult(&#10;                true,&#10;                &quot;¡Perfecto! Seña de 'Amigo' completada&quot;,&#10;                1.0f&#10;            )&#10;&#10;        } catch (e: Exception) {&#10;            return SignAmigoValidationResult(&#10;                false,&#10;                &quot;Error en la validación&quot;,&#10;                0f&#10;            )&#10;        }&#10;    }&#10;&#10;    data class SignAmigoValidationResult(&#10;        val isValid: Boolean,&#10;        val message: String,&#10;        val confidence: Float&#10;    )&#10;&#10;    // Clases de datos para resultados&#10;    data class LetterZValidationResult(&#10;        val isValid: Boolean,&#10;        val message: String,&#10;        val confidence: Float&#10;    )&#10;&#10;    private data class ZDetectionResult(&#10;        val isZ: Boolean,&#10;        val confidence: Float&#10;    )&#10;&#10;    // Funciones auxiliares para análisis de landmarks&#10;&#10;    private enum class FingerType(val tipIndex: Int, val pipIndex: Int, val mcpIndex: Int) {&#10;        INDEX(8, 7, 5),&#10;        MIDDLE(12, 11, 9),&#10;        RING(16, 15, 13),&#10;        PINKY(20, 19, 17)&#10;    }&#10;&#10;    /**&#10;     * Determina si un dedo específico está extendido&#10;     */&#10;    private fun isFingerExtended(landmarks: List&lt;com.google.mediapipe.tasks.components.containers.NormalizedLandmark&gt;, finger: FingerType): Boolean {&#10;        val tipY = landmarks[finger.tipIndex].y()&#10;        val pipY = landmarks[finger.pipIndex].y()&#10;        val mcpY = landmarks[finger.mcpIndex].y()&#10;&#10;        // Un dedo está extendido si la punta está más arriba que las articulaciones&#10;        return tipY &lt; pipY &amp;&amp; pipY &lt; mcpY&#10;    }&#10;&#10;    /**&#10;     * Determina si el pulgar está extendido&#10;     */&#10;    private fun isThumbExtended(landmarks: List&lt;com.google.mediapipe.tasks.components.containers.NormalizedLandmark&gt;): Boolean {&#10;        val thumbTip = landmarks[4]&#10;        val thumbMcp = landmarks[2]&#10;        val wrist = landmarks[0]&#10;&#10;        // Calcular la distancia del pulgar desde la muñeca&#10;        val tipDistance = distance(thumbTip.x(), thumbTip.y(), wrist.x(), wrist.y())&#10;        val mcpDistance = distance(thumbMcp.x(), thumbMcp.y(), wrist.x(), wrist.y())&#10;&#10;        return tipDistance &gt; mcpDistance * 1.2f&#10;    }&#10;&#10;    /**&#10;     * Verifica si el pulgar está cubriendo las puntas de los dedos (para letra E)&#10;     */&#10;    private fun isThumbCoveringFingers(landmarks: List&lt;com.google.mediapipe.tasks.components.containers.NormalizedLandmark&gt;): Boolean {&#10;        val thumbTip = landmarks[4]&#10;        val indexTip = landmarks[8]&#10;        val middleTip = landmarks[12]&#10;&#10;        // El pulgar debe estar cerca de las puntas de los otros dedos&#10;        val distToIndex = distance(thumbTip.x(), thumbTip.y(), indexTip.x(), indexTip.y())&#10;        val distToMiddle = distance(thumbTip.x(), thumbTip.y(), middleTip.x(), middleTip.y())&#10;&#10;        return distToIndex &lt; 0.05f || distToMiddle &lt; 0.05f&#10;    }&#10;&#10;    /**&#10;     * Verifica si las puntas de los dedos forman un círculo (para letra O)&#10;     */&#10;    private fun areFingertipsFormingCircle(landmarks: List&lt;com.google.mediapipe.tasks.components.containers.NormalizedLandmark&gt;): Boolean {&#10;        val thumbTip = landmarks[4]&#10;        val indexTip = landmarks[8]&#10;        val middleTip = landmarks[12]&#10;&#10;        // Las puntas deben estar relativamente cerca entre sí&#10;        val thumbIndexDist = distance(thumbTip.x(), thumbTip.y(), indexTip.x(), indexTip.y())&#10;        val thumbMiddleDist = distance(thumbTip.x(), thumbTip.y(), middleTip.x(), middleTip.y())&#10;&#10;        return thumbIndexDist &lt; 0.08f &amp;&amp; thumbMiddleDist &lt; 0.1f&#10;    }&#10;&#10;    /**&#10;     * Verifica si los dedos están curvados apropiadamente para la letra O&#10;     */&#10;    private fun areFingersCurvedForO(landmarks: List&lt;com.google.mediapipe.tasks.components.containers.NormalizedLandmark&gt;): Boolean {&#10;        // Los dedos no deben estar completamente extendidos&#10;        val indexExtended = isFingerExtended(landmarks, FingerType.INDEX)&#10;        val middleExtended = isFingerExtended(landmarks, FingerType.MIDDLE)&#10;&#10;        return !indexExtended &amp;&amp; !middleExtended&#10;    }&#10;&#10;&#10;    /**&#10;     * Calcula la distancia euclidiana entre dos puntos&#10;     */&#10;    private fun distance(x1: Float, y1: Float, x2: Float, y2: Float): Float {&#10;        return sqrt((x2 - x1).pow(2) + (y2 - y1).pow(2))&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/ecohand/presentation/senas/CategorySelectionScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/ecohand/presentation/senas/CategorySelectionScreen.kt" />
              <option name="originalContent" value="package com.example.ecohand.presentation.senas&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.automirrored.filled.ArrowForward&#10;import androidx.compose.material.icons.filled.Person&#10;import androidx.compose.material.icons.filled.Star&#10;import androidx.compose.material.icons.filled.Info&#10;import androidx.compose.material.icons.filled.Build&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.vector.ImageVector&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun CategorySelectionScreen(&#10;    onNavigateBack: () -&gt; Unit,&#10;    onCategorySelected: (String) -&gt; Unit&#10;) {&#10;    val categories = listOf(&#10;        CategoryInfo(&#10;            name = &quot;Alfabeto&quot;,&#10;            description = &quot;Letras y vocales en LSP&quot;,&#10;            icon = Icons.Default.Star,&#10;            available = true,&#10;            itemCount = 6 // A, E, I, O, U, Z&#10;        ),&#10;        CategoryInfo(&#10;            name = &quot;Relaciones Familiares&quot;,&#10;            description = &quot;Señas sobre la familia&quot;,&#10;            icon = Icons.Default.Person,&#10;            available = true,&#10;            itemCount = 1&#10;        ),&#10;        CategoryInfo(&#10;            name = &quot;Adverbios&quot;,&#10;            description = &quot;Señas de adverbios&quot;,&#10;            icon = Icons.Default.Info,&#10;            available = false,&#10;            itemCount = 0&#10;        ),&#10;        CategoryInfo(&#10;            name = &quot;Verbos&quot;,&#10;            description = &quot;Acciones y verbos&quot;,&#10;            icon = Icons.Default.Build,&#10;            available = false,&#10;            itemCount = 0&#10;        )&#10;    )&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = {&#10;                    Text(&#10;                        text = &quot;Categorías de Señas&quot;,&#10;                        fontWeight = FontWeight.Bold,&#10;                        fontSize = 18.sp&#10;                    )&#10;                },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onNavigateBack) {&#10;                        Icon(&#10;                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                            contentDescription = &quot;Volver&quot;&#10;                        )&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = MaterialTheme.colorScheme.primary,&#10;                    titleContentColor = MaterialTheme.colorScheme.onPrimary,&#10;                    navigationIconContentColor = MaterialTheme.colorScheme.onPrimary&#10;                )&#10;            )&#10;        }&#10;    ) { paddingValues -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues)&#10;                .background(MaterialTheme.colorScheme.background)&#10;                .padding(16.dp),&#10;            verticalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            // Título e instrucciones&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.primaryContainer&#10;                ),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(20.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    Text(&#10;                        text = &quot;️ Validación de Señas&quot;,&#10;                        fontSize = 24.sp,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = MaterialTheme.colorScheme.onPrimaryContainer&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    Text(&#10;                        text = &quot;Selecciona una categoría para practicar&quot;,&#10;                        fontSize = 16.sp,&#10;                        color = MaterialTheme.colorScheme.onPrimaryContainer.copy(alpha = 0.8f),&#10;                        textAlign = TextAlign.Center&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Lista de categorías&#10;            LazyColumn(&#10;                verticalArrangement = Arrangement.spacedBy(12.dp)&#10;            ) {&#10;                items(categories) { categoryInfo -&gt;&#10;                    CategoryCard(&#10;                        categoryInfo = categoryInfo,&#10;                        onCategoryClick = {&#10;                            if (categoryInfo.available) {&#10;                                onCategorySelected(categoryInfo.name)&#10;                            }&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun CategoryCard(&#10;    categoryInfo: CategoryInfo,&#10;    onCategoryClick: () -&gt; Unit&#10;) {&#10;    ElevatedCard(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        onClick = onCategoryClick,&#10;        colors = CardDefaults.elevatedCardColors(&#10;            containerColor = if (categoryInfo.available) {&#10;                MaterialTheme.colorScheme.surface&#10;            } else {&#10;                MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.5f)&#10;            }&#10;        ),&#10;        elevation = CardDefaults.elevatedCardElevation(&#10;            defaultElevation = if (categoryInfo.available) 6.dp else 2.dp&#10;        ),&#10;        enabled = categoryInfo.available&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(20.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Icono de la categoría&#10;            Box(&#10;                modifier = Modifier&#10;                    .size(60.dp)&#10;                    .background(&#10;                        if (categoryInfo.available) {&#10;                            MaterialTheme.colorScheme.primaryContainer&#10;                        } else {&#10;                            MaterialTheme.colorScheme.surfaceVariant&#10;                        },&#10;                        RoundedCornerShape(30.dp)&#10;                    ),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Icon(&#10;                    imageVector = categoryInfo.icon,&#10;                    contentDescription = categoryInfo.name,&#10;                    modifier = Modifier.size(32.dp),&#10;                    tint = if (categoryInfo.available) {&#10;                        MaterialTheme.colorScheme.onPrimaryContainer&#10;                    } else {&#10;                        MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.5f)&#10;                    }&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.width(16.dp))&#10;&#10;            // Información de la categoría&#10;            Column(&#10;                modifier = Modifier.weight(1f)&#10;            ) {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Text(&#10;                        text = categoryInfo.name,&#10;                        fontSize = 18.sp,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = if (categoryInfo.available) {&#10;                            MaterialTheme.colorScheme.onSurface&#10;                        } else {&#10;                            MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.5f)&#10;                        }&#10;                    )&#10;&#10;                    if (!categoryInfo.available) {&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                        Surface(&#10;                            color = MaterialTheme.colorScheme.secondary.copy(alpha = 0.2f),&#10;                            shape = RoundedCornerShape(12.dp)&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;Próximamente&quot;,&#10;                                fontSize = 10.sp,&#10;                                fontWeight = FontWeight.Medium,&#10;                                color = MaterialTheme.colorScheme.secondary,&#10;                                modifier = Modifier.padding(horizontal = 8.dp, vertical = 4.dp)&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;&#10;                Text(&#10;                    text = categoryInfo.description,&#10;                    fontSize = 14.sp,&#10;                    color = if (categoryInfo.available) {&#10;                        MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)&#10;                    } else {&#10;                        MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.5f)&#10;                    }&#10;                )&#10;&#10;                if (categoryInfo.available &amp;&amp; categoryInfo.itemCount &gt; 0) {&#10;                    Spacer(modifier = Modifier.height(4.dp))&#10;                    Text(&#10;                        text = &quot;${categoryInfo.itemCount} señas disponibles&quot;,&#10;                        fontSize = 12.sp,&#10;                        color = MaterialTheme.colorScheme.primary,&#10;                        fontWeight = FontWeight.Medium&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Flecha indicadora&#10;            if (categoryInfo.available) {&#10;                Icon(&#10;                    imageVector = Icons.AutoMirrored.Filled.ArrowForward,&#10;                    contentDescription = &quot;Ir a ${categoryInfo.name}&quot;,&#10;                    tint = MaterialTheme.colorScheme.primary&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;data class CategoryInfo(&#10;    val name: String,&#10;    val description: String,&#10;    val icon: ImageVector,&#10;    val available: Boolean,&#10;    val itemCount: Int&#10;)&#10;&#10;" />
              <option name="updatedContent" value="package com.example.ecohand.presentation.senas&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.automirrored.filled.ArrowForward&#10;import androidx.compose.material.icons.filled.Person&#10;import androidx.compose.material.icons.filled.Star&#10;import androidx.compose.material.icons.filled.Info&#10;import androidx.compose.material.icons.filled.Build&#10;import androidx.compose.material.icons.filled.Phone&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.vector.ImageVector&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun CategorySelectionScreen(&#10;    onNavigateBack: () -&gt; Unit,&#10;    onCategorySelected: (String) -&gt; Unit&#10;) {&#10;    val categories = listOf(&#10;        CategoryInfo(&#10;            name = &quot;Alfabeto&quot;,&#10;            description = &quot;Letras y vocales en LSP&quot;,&#10;            icon = Icons.Default.Star,&#10;            available = true,&#10;            itemCount = 6 // A, E, I, O, U, Z&#10;        ),&#10;        CategoryInfo(&#10;            name = &quot;Relaciones Familiares&quot;,&#10;            description = &quot;Señas sobre la familia&quot;,&#10;            icon = Icons.Default.Person,&#10;            available = true,&#10;            itemCount = 1&#10;        ),&#10;        CategoryInfo(&#10;            name = &quot;Números&quot;,&#10;            description = &quot;Números del 0 al 5 en LSP&quot;,&#10;            icon = Icons.Default.Phone,&#10;            available = true,&#10;            itemCount = 6 // 0, 1, 2, 3, 4, 5&#10;        )&#10;    )&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = {&#10;                    Text(&#10;                        text = &quot;Categorías de Señas&quot;,&#10;                        fontWeight = FontWeight.Bold,&#10;                        fontSize = 18.sp&#10;                    )&#10;                },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onNavigateBack) {&#10;                        Icon(&#10;                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                            contentDescription = &quot;Volver&quot;&#10;                        )&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = MaterialTheme.colorScheme.primary,&#10;                    titleContentColor = MaterialTheme.colorScheme.onPrimary,&#10;                    navigationIconContentColor = MaterialTheme.colorScheme.onPrimary&#10;                )&#10;            )&#10;        }&#10;    ) { paddingValues -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues)&#10;                .background(MaterialTheme.colorScheme.background)&#10;                .padding(16.dp),&#10;            verticalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            // Título e instrucciones&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.primaryContainer&#10;                ),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(20.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    Text(&#10;                        text = &quot;️ Validación de Señas&quot;,&#10;                        fontSize = 24.sp,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = MaterialTheme.colorScheme.onPrimaryContainer&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    Text(&#10;                        text = &quot;Selecciona una categoría para practicar&quot;,&#10;                        fontSize = 16.sp,&#10;                        color = MaterialTheme.colorScheme.onPrimaryContainer.copy(alpha = 0.8f),&#10;                        textAlign = TextAlign.Center&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Lista de categorías&#10;            LazyColumn(&#10;                verticalArrangement = Arrangement.spacedBy(12.dp)&#10;            ) {&#10;                items(categories) { categoryInfo -&gt;&#10;                    CategoryCard(&#10;                        categoryInfo = categoryInfo,&#10;                        onCategoryClick = {&#10;                            if (categoryInfo.available) {&#10;                                onCategorySelected(categoryInfo.name)&#10;                            }&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun CategoryCard(&#10;    categoryInfo: CategoryInfo,&#10;    onCategoryClick: () -&gt; Unit&#10;) {&#10;    ElevatedCard(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        onClick = onCategoryClick,&#10;        colors = CardDefaults.elevatedCardColors(&#10;            containerColor = if (categoryInfo.available) {&#10;                MaterialTheme.colorScheme.surface&#10;            } else {&#10;                MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.5f)&#10;            }&#10;        ),&#10;        elevation = CardDefaults.elevatedCardElevation(&#10;            defaultElevation = if (categoryInfo.available) 6.dp else 2.dp&#10;        ),&#10;        enabled = categoryInfo.available&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(20.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Icono de la categoría&#10;            Box(&#10;                modifier = Modifier&#10;                    .size(60.dp)&#10;                    .background(&#10;                        if (categoryInfo.available) {&#10;                            MaterialTheme.colorScheme.primaryContainer&#10;                        } else {&#10;                            MaterialTheme.colorScheme.surfaceVariant&#10;                        },&#10;                        RoundedCornerShape(30.dp)&#10;                    ),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Icon(&#10;                    imageVector = categoryInfo.icon,&#10;                    contentDescription = categoryInfo.name,&#10;                    modifier = Modifier.size(32.dp),&#10;                    tint = if (categoryInfo.available) {&#10;                        MaterialTheme.colorScheme.onPrimaryContainer&#10;                    } else {&#10;                        MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.5f)&#10;                    }&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.width(16.dp))&#10;&#10;            // Información de la categoría&#10;            Column(&#10;                modifier = Modifier.weight(1f)&#10;            ) {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Text(&#10;                        text = categoryInfo.name,&#10;                        fontSize = 18.sp,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = if (categoryInfo.available) {&#10;                            MaterialTheme.colorScheme.onSurface&#10;                        } else {&#10;                            MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.5f)&#10;                        }&#10;                    )&#10;&#10;                    if (!categoryInfo.available) {&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                        Surface(&#10;                            color = MaterialTheme.colorScheme.secondary.copy(alpha = 0.2f),&#10;                            shape = RoundedCornerShape(12.dp)&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;Próximamente&quot;,&#10;                                fontSize = 10.sp,&#10;                                fontWeight = FontWeight.Medium,&#10;                                color = MaterialTheme.colorScheme.secondary,&#10;                                modifier = Modifier.padding(horizontal = 8.dp, vertical = 4.dp)&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;&#10;                Text(&#10;                    text = categoryInfo.description,&#10;                    fontSize = 14.sp,&#10;                    color = if (categoryInfo.available) {&#10;                        MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)&#10;                    } else {&#10;                        MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.5f)&#10;                    }&#10;                )&#10;&#10;                if (categoryInfo.available &amp;&amp; categoryInfo.itemCount &gt; 0) {&#10;                    Spacer(modifier = Modifier.height(4.dp))&#10;                    Text(&#10;                        text = &quot;${categoryInfo.itemCount} señas disponibles&quot;,&#10;                        fontSize = 12.sp,&#10;                        color = MaterialTheme.colorScheme.primary,&#10;                        fontWeight = FontWeight.Medium&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Flecha indicadora&#10;            if (categoryInfo.available) {&#10;                Icon(&#10;                    imageVector = Icons.AutoMirrored.Filled.ArrowForward,&#10;                    contentDescription = &quot;Ir a ${categoryInfo.name}&quot;,&#10;                    tint = MaterialTheme.colorScheme.primary&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;data class CategoryInfo(&#10;    val name: String,&#10;    val description: String,&#10;    val icon: ImageVector,&#10;    val available: Boolean,&#10;    val itemCount: Int&#10;)&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/ecohand/presentation/senas/VowelSelectionScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/ecohand/presentation/senas/VowelSelectionScreen.kt" />
              <option name="originalContent" value="package com.example.ecohand.presentation.senas&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.automirrored.filled.ArrowForward&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun VowelSelectionScreen(&#10;    category: String,&#10;    onNavigateBack: () -&gt; Unit,&#10;    onVowelSelected: (String) -&gt; Unit&#10;) {&#10;    // Obtener las señas según la categoría&#10;    val vowels = when (category) {&#10;        &quot;Alfabeto&quot; -&gt; listOf(&#10;            VowelInfo(&quot;A&quot;, &quot;Pulgar extendido hacia afuera, demás dedos cerrados&quot;),&#10;            VowelInfo(&quot;E&quot;, &quot;Todos los dedos curvados, pulgar cubriendo puntas&quot;),&#10;            VowelInfo(&quot;I&quot;, &quot;Solo meñique extendido hacia arriba&quot;),&#10;            VowelInfo(&quot;O&quot;, &quot;Dedos formando un círculo&quot;),&#10;            VowelInfo(&quot;U&quot;, &quot;Índice y meñique extendidos hacia arriba&quot;),&#10;            VowelInfo(&quot;Z&quot;, &quot;Índice extendido trazando una Z (requiere movimiento)&quot;)&#10;        )&#10;        &quot;Relaciones Familiares&quot; -&gt; listOf(&#10;            VowelInfo(&quot;Amigo&quot;, &quot;Coloca una mano arriba y otra abajo, cerca&quot;)&#10;        )&#10;        else -&gt; emptyList() // Otras categorías próximamente&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = {&#10;                    Text(&#10;                        text = category,&#10;                        fontWeight = FontWeight.Bold,&#10;                        fontSize = 18.sp&#10;                    )&#10;                },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onNavigateBack) {&#10;                        Icon(&#10;                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                            contentDescription = &quot;Volver&quot;&#10;                        )&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = MaterialTheme.colorScheme.primary,&#10;                    titleContentColor = MaterialTheme.colorScheme.onPrimary,&#10;                    navigationIconContentColor = MaterialTheme.colorScheme.onPrimary&#10;                )&#10;            )&#10;        }&#10;    ) { paddingValues -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues)&#10;                .background(MaterialTheme.colorScheme.background)&#10;                .padding(16.dp),&#10;            verticalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            // Título e instrucciones&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.primaryContainer&#10;                ),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(20.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    Text(&#10;                        text = &quot;️ $category&quot;,&#10;                        fontSize = 24.sp,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = MaterialTheme.colorScheme.onPrimaryContainer&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    Text(&#10;                        text = &quot;Selecciona la seña que quieres practicar&quot;,&#10;                        fontSize = 16.sp,&#10;                        color = MaterialTheme.colorScheme.onPrimaryContainer.copy(alpha = 0.8f),&#10;                        textAlign = TextAlign.Center&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Lista de vocales&#10;            LazyColumn(&#10;                verticalArrangement = Arrangement.spacedBy(12.dp)&#10;            ) {&#10;                items(vowels) { vowelInfo -&gt;&#10;                    VowelCard(&#10;                        vowelInfo = vowelInfo,&#10;                        onVowelClick = { onVowelSelected(vowelInfo.letter) }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun VowelCard(&#10;    vowelInfo: VowelInfo,&#10;    onVowelClick: () -&gt; Unit&#10;) {&#10;    ElevatedCard(&#10;        modifier = Modifier&#10;            .fillMaxWidth(),&#10;        onClick = onVowelClick,&#10;        colors = CardDefaults.elevatedCardColors(&#10;            containerColor = MaterialTheme.colorScheme.surface&#10;        ),&#10;        elevation = CardDefaults.elevatedCardElevation(defaultElevation = 6.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(20.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Icono de la vocal&#10;            Box(&#10;                modifier = Modifier&#10;                    .size(60.dp)&#10;                    .background(&#10;                        MaterialTheme.colorScheme.primaryContainer,&#10;                        RoundedCornerShape(30.dp)&#10;                    ),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Text(&#10;                    text = vowelInfo.letter.take(1),&#10;                    fontSize = 28.sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = MaterialTheme.colorScheme.onPrimaryContainer&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.width(16.dp))&#10;&#10;            // Información de la vocal&#10;            Column(&#10;                modifier = Modifier.weight(1f)&#10;            ) {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Text(&#10;                        text = vowelInfo.letter,&#10;                        fontSize = 20.sp,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = MaterialTheme.colorScheme.onSurface&#10;                    )&#10;&#10;                }&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;                Text(&#10;                    text = vowelInfo.description,&#10;                    fontSize = 14.sp,&#10;                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)&#10;                )&#10;            }&#10;&#10;            // Flecha indicadora&#10;            Icon(&#10;                imageVector = Icons.AutoMirrored.Filled.ArrowForward,&#10;                contentDescription = &quot;Ir&quot;,&#10;                modifier = Modifier.size(24.dp),&#10;                tint = MaterialTheme.colorScheme.primary&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;data class VowelInfo(&#10;    val letter: String,&#10;    val description: String&#10;)&#10;" />
              <option name="updatedContent" value="package com.example.ecohand.presentation.senas&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.automirrored.filled.ArrowForward&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun VowelSelectionScreen(&#10;    category: String,&#10;    onNavigateBack: () -&gt; Unit,&#10;    onVowelSelected: (String) -&gt; Unit&#10;) {&#10;    // Obtener las señas según la categoría&#10;    val vowels = when (category) {&#10;        &quot;Alfabeto&quot; -&gt; listOf(&#10;            VowelInfo(&quot;A&quot;, &quot;Pulgar extendido hacia afuera, demás dedos cerrados&quot;),&#10;            VowelInfo(&quot;E&quot;, &quot;Todos los dedos curvados, pulgar cubriendo puntas&quot;),&#10;            VowelInfo(&quot;I&quot;, &quot;Solo meñique extendido hacia arriba&quot;),&#10;            VowelInfo(&quot;O&quot;, &quot;Dedos formando un círculo&quot;),&#10;            VowelInfo(&quot;U&quot;, &quot;Índice y meñique extendidos hacia arriba&quot;),&#10;            VowelInfo(&quot;Z&quot;, &quot;Índice extendido trazando una Z (requiere movimiento)&quot;)&#10;        )&#10;        &quot;Relaciones Familiares&quot; -&gt; listOf(&#10;            VowelInfo(&quot;Amigo&quot;, &quot;Coloca una mano arriba y otra abajo, cerca&quot;)&#10;        )&#10;        &quot;Números&quot; -&gt; listOf(&#10;            VowelInfo(&quot;0&quot;, &quot;Todos los dedos curvados formando un círculo, puntas de los dedos tocando la punta del pulgar&quot;),&#10;            VowelInfo(&quot;1&quot;, &quot;Solo el dedo índice extendido hacia arriba, demás dedos cerrados&quot;),&#10;            VowelInfo(&quot;2&quot;, &quot;Dedos índice y medio extendidos hacia arriba formando una V&quot;),&#10;            VowelInfo(&quot;3&quot;, &quot;Dedos índice, medio y anular extendidos hacia arriba&quot;),&#10;            VowelInfo(&quot;4&quot;, &quot;Los cuatro dedos extendidos hacia arriba, pulgar doblado hacia la palma&quot;),&#10;            VowelInfo(&quot;5&quot;, &quot;Todos los dedos extendidos y separados, mano abierta completa&quot;)&#10;        )&#10;        else -&gt; emptyList() // Otras categorías próximamente&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = {&#10;                    Text(&#10;                        text = category,&#10;                        fontWeight = FontWeight.Bold,&#10;                        fontSize = 18.sp&#10;                    )&#10;                },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onNavigateBack) {&#10;                        Icon(&#10;                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                            contentDescription = &quot;Volver&quot;&#10;                        )&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = MaterialTheme.colorScheme.primary,&#10;                    titleContentColor = MaterialTheme.colorScheme.onPrimary,&#10;                    navigationIconContentColor = MaterialTheme.colorScheme.onPrimary&#10;                )&#10;            )&#10;        }&#10;    ) { paddingValues -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues)&#10;                .background(MaterialTheme.colorScheme.background)&#10;                .padding(16.dp),&#10;            verticalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            // Título e instrucciones&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.primaryContainer&#10;                ),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(20.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    Text(&#10;                        text = &quot;️ $category&quot;,&#10;                        fontSize = 24.sp,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = MaterialTheme.colorScheme.onPrimaryContainer&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    Text(&#10;                        text = &quot;Selecciona la seña que quieres practicar&quot;,&#10;                        fontSize = 16.sp,&#10;                        color = MaterialTheme.colorScheme.onPrimaryContainer.copy(alpha = 0.8f),&#10;                        textAlign = TextAlign.Center&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Lista de vocales&#10;            LazyColumn(&#10;                verticalArrangement = Arrangement.spacedBy(12.dp)&#10;            ) {&#10;                items(vowels) { vowelInfo -&gt;&#10;                    VowelCard(&#10;                        vowelInfo = vowelInfo,&#10;                        onVowelClick = { onVowelSelected(vowelInfo.letter) }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun VowelCard(&#10;    vowelInfo: VowelInfo,&#10;    onVowelClick: () -&gt; Unit&#10;) {&#10;    ElevatedCard(&#10;        modifier = Modifier&#10;            .fillMaxWidth(),&#10;        onClick = onVowelClick,&#10;        colors = CardDefaults.elevatedCardColors(&#10;            containerColor = MaterialTheme.colorScheme.surface&#10;        ),&#10;        elevation = CardDefaults.elevatedCardElevation(defaultElevation = 6.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(20.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Icono de la vocal&#10;            Box(&#10;                modifier = Modifier&#10;                    .size(60.dp)&#10;                    .background(&#10;                        MaterialTheme.colorScheme.primaryContainer,&#10;                        RoundedCornerShape(30.dp)&#10;                    ),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Text(&#10;                    text = vowelInfo.letter.take(1),&#10;                    fontSize = 28.sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = MaterialTheme.colorScheme.onPrimaryContainer&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.width(16.dp))&#10;&#10;            // Información de la vocal&#10;            Column(&#10;                modifier = Modifier.weight(1f)&#10;            ) {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Text(&#10;                        text = vowelInfo.letter,&#10;                        fontSize = 20.sp,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = MaterialTheme.colorScheme.onSurface&#10;                    )&#10;&#10;                }&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;                Text(&#10;                    text = vowelInfo.description,&#10;                    fontSize = 14.sp,&#10;                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)&#10;                )&#10;            }&#10;&#10;            // Flecha indicadora&#10;            Icon(&#10;                imageVector = Icons.AutoMirrored.Filled.ArrowForward,&#10;                contentDescription = &quot;Ir&quot;,&#10;                modifier = Modifier.size(24.dp),&#10;                tint = MaterialTheme.colorScheme.primary&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;data class VowelInfo(&#10;    val letter: String,&#10;    val description: String&#10;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/ecohand/presentation/senas/VowelValidationScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/ecohand/presentation/senas/VowelValidationScreen.kt" />
              <option name="originalContent" value="package com.example.ecohand.presentation.senas&#10;&#10;import android.Manifest&#10;import android.content.pm.PackageManager&#10;import android.graphics.Bitmap&#10;import android.graphics.Matrix&#10;import android.util.Log&#10;import android.view.ViewGroup&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.camera.core.CameraSelector&#10;import androidx.camera.core.ImageAnalysis&#10;import androidx.camera.core.ImageProxy&#10;import androidx.camera.core.Preview&#10;import androidx.camera.lifecycle.ProcessCameraProvider&#10;import androidx.camera.view.PreviewView&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Check&#10;import androidx.compose.material.icons.filled.Refresh&#10;import androidx.compose.material.icons.filled.Info&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalLifecycleOwner&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;import androidx.core.content.ContextCompat&#10;import com.example.ecohand.ml.FaceDetector&#10;import com.example.ecohand.ml.HandDetector&#10;import com.example.ecohand.ml.VowelSignValidator&#10;import com.example.ecohand.presentation.components.DetectionOverlay&#10;import com.google.mediapipe.tasks.vision.core.RunningMode&#10;import com.google.mediapipe.tasks.vision.facelandmarker.FaceLandmarkerResult&#10;import com.google.mediapipe.tasks.vision.handlandmarker.HandLandmarkerResult&#10;import java.util.concurrent.Executors&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun VowelValidationScreen(&#10;    vowel: String,&#10;    onNavigateBack: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;&#10;    var hasCameraPermission by remember {&#10;        mutableStateOf(&#10;            ContextCompat.checkSelfPermission(&#10;                context,&#10;                Manifest.permission.CAMERA&#10;            ) == PackageManager.PERMISSION_GRANTED&#10;        )&#10;    }&#10;&#10;    val launcher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.RequestPermission(),&#10;        onResult = { granted -&gt;&#10;            hasCameraPermission = granted&#10;        }&#10;    )&#10;&#10;    var useFrontCamera by remember { mutableStateOf(true) }&#10;    var handResults by remember { mutableStateOf&lt;HandLandmarkerResult?&gt;(null) }&#10;    var faceResults by remember { mutableStateOf&lt;FaceLandmarkerResult?&gt;(null) }&#10;    var imageWidth by remember { mutableStateOf(640) }&#10;    var imageHeight by remember { mutableStateOf(480) }&#10;    var detectionStatus by remember { mutableStateOf(&quot;Inicializando...&quot;) }&#10;    var validationResult by remember { mutableStateOf&lt;ValidationState&gt;(ValidationState.Detecting) }&#10;    var showSuccessDialog by remember { mutableStateOf(false) }&#10;    var showInfoDialog by remember { mutableStateOf(false) }&#10;&#10;    // Detectores y validador&#10;    val handDetector = remember {&#10;        HandDetector(&#10;            context = context,&#10;            runningMode = RunningMode.LIVE_STREAM,&#10;            maxNumHands = 2 // Detectar hasta 2 manos (necesario para señas como &quot;Amigo&quot;)&#10;        )&#10;    }&#10;&#10;    val faceDetector = remember {&#10;        FaceDetector(&#10;            context = context,&#10;            runningMode = RunningMode.LIVE_STREAM,&#10;            maxNumFaces = 1&#10;        )&#10;    }&#10;&#10;    val vowelValidator = remember { VowelSignValidator() }&#10;&#10;    // Inicializar detectores&#10;    LaunchedEffect(Unit) {&#10;        if (!hasCameraPermission) {&#10;            launcher.launch(Manifest.permission.CAMERA)&#10;        }&#10;&#10;        val handInit = handDetector.initialize { result, _ -&gt;&#10;            handResults = result&#10;            // Validar la seña automáticamente&#10;            validationResult = validateVowelSign(result, vowel, vowelValidator)&#10;        }&#10;&#10;        val faceInit = faceDetector.initialize { result, _ -&gt;&#10;            faceResults = result&#10;        }&#10;&#10;        detectionStatus = when {&#10;            handInit &amp;&amp; faceInit -&gt; &quot;✓ Detectores listos&quot;&#10;            handInit -&gt; &quot;⚠ Solo manos listo&quot;&#10;            faceInit -&gt; &quot;⚠ Solo rostro listo&quot;&#10;            else -&gt; &quot;✗ Error al inicializar&quot;&#10;        }&#10;    }&#10;&#10;    // Mostrar diálogo de éxito cuando se valide correctamente&#10;    LaunchedEffect(validationResult) {&#10;        if (validationResult is ValidationState.Success) {&#10;            showSuccessDialog = true&#10;        }&#10;    }&#10;&#10;    // Limpiar recursos&#10;    DisposableEffect(Unit) {&#10;        onDispose {&#10;            handDetector.close()&#10;            faceDetector.close()&#10;            // Limpiar trayectorias de letras con movimiento&#10;            vowelValidator.resetZTrajectory()&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = {&#10;                    Text(&#10;                        text = &quot;Validar: $vowel&quot;,&#10;                        fontWeight = FontWeight.Bold,&#10;                        fontSize = 18.sp&#10;                    )&#10;                },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onNavigateBack) {&#10;                        Icon(&#10;                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                            contentDescription = &quot;Volver&quot;&#10;                        )&#10;                    }&#10;                },&#10;                actions = {&#10;                    // Botón de información&#10;                    IconButton(onClick = { showInfoDialog = true }) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Info,&#10;                            contentDescription = &quot;Ver información&quot;&#10;                        )&#10;                    }&#10;                    // Botón para cambiar cámara&#10;                    IconButton(onClick = { useFrontCamera = !useFrontCamera }) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Refresh,&#10;                            contentDescription = &quot;Cambiar cámara&quot;&#10;                        )&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = MaterialTheme.colorScheme.primary,&#10;                    titleContentColor = MaterialTheme.colorScheme.onPrimary,&#10;                    navigationIconContentColor = MaterialTheme.colorScheme.onPrimary,&#10;                    actionIconContentColor = MaterialTheme.colorScheme.onPrimary&#10;                )&#10;            )&#10;        }&#10;    ) { paddingValues -&gt;&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues)&#10;                .background(MaterialTheme.colorScheme.background)&#10;        ) {&#10;            // Vista de cámara con overlay ocupando todo el espacio&#10;            if (hasCameraPermission) {&#10;                // Cámara con key para forzar recomposición al cambiar de cámara&#10;                key(useFrontCamera) {&#10;                    CameraPreviewWithValidation(&#10;                        useFrontCamera = useFrontCamera,&#10;                        handDetector = handDetector,&#10;                        faceDetector = faceDetector,&#10;                        onImageDimensionsChanged = { width, height -&gt;&#10;                            imageWidth = width&#10;                            imageHeight = height&#10;                        }&#10;                    )&#10;                }&#10;&#10;                // Overlay de detecciones&#10;                DetectionOverlay(&#10;                    handResults = handResults,&#10;                    faceResults = faceResults,&#10;                    imageWidth = imageWidth,&#10;                    imageHeight = imageHeight,&#10;                    modifier = Modifier.fillMaxSize()&#10;                )&#10;&#10;                // Overlay de estado en la parte superior (texto sin fondo)&#10;                Column(&#10;                    modifier = Modifier&#10;                        .align(Alignment.TopCenter)&#10;                        .fillMaxWidth()&#10;                        .padding(16.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    // Estado de validación (texto con sombra para visibilidad)&#10;                    Text(&#10;                        text = when (validationResult) {&#10;                            is ValidationState.Detecting -&gt; &quot; Detectando...&quot;&#10;                            is ValidationState.Success -&gt; &quot;✅ ¡Correcto!&quot;&#10;                            is ValidationState.Error -&gt; &quot;❌ ${(validationResult as ValidationState.Error).message}&quot;&#10;                            is ValidationState.Waiting -&gt; &quot;⏳ Esperando seña...&quot;&#10;                        },&#10;                        fontSize = 20.sp,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = when (validationResult) {&#10;                            is ValidationState.Success -&gt; Color(0xFF4CAF50)&#10;                            is ValidationState.Error -&gt; Color(0xFFF44336)&#10;                            else -&gt; Color.White&#10;                        },&#10;                        style = androidx.compose.ui.text.TextStyle(&#10;                            shadow = androidx.compose.ui.graphics.Shadow(&#10;                                color = Color.Black,&#10;                                offset = androidx.compose.ui.geometry.Offset(2f, 2f),&#10;                                blurRadius = 4f&#10;                            )&#10;                        ),&#10;                        textAlign = TextAlign.Center&#10;                    )&#10;                }&#10;            } else {&#10;                PermissionRequestCard(onRequestPermission = {&#10;                    launcher.launch(Manifest.permission.CAMERA)&#10;                })&#10;            }&#10;        }&#10;    }&#10;&#10;    // Diálogo de éxito&#10;    if (showSuccessDialog) {&#10;        AlertDialog(&#10;            onDismissRequest = { },&#10;            title = {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    horizontalArrangement = Arrangement.Center,&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Check,&#10;                        contentDescription = &quot;Éxito&quot;,&#10;                        tint = Color(0xFF4CAF50),&#10;                        modifier = Modifier.size(32.dp)&#10;                    )&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;                    Text(&#10;                        text = &quot;¡Correcto!&quot;,&#10;                        fontSize = 24.sp,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = Color(0xFF4CAF50)&#10;                    )&#10;                }&#10;            },&#10;            text = {&#10;                Column(&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    Text(&#10;                        text = &quot;&quot;,&#10;                        fontSize = 48.sp&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    Text(&#10;                        text = &quot;Has realizado correctamente la seña: $vowel&quot;,&#10;                        textAlign = TextAlign.Center,&#10;                        fontSize = 16.sp&#10;                    )&#10;                }&#10;            },&#10;            confirmButton = {&#10;                Button(&#10;                    onClick = {&#10;                        showSuccessDialog = false&#10;                        onNavigateBack()&#10;                    },&#10;                    colors = ButtonDefaults.buttonColors(&#10;                        containerColor = Color(0xFF4CAF50)&#10;                    )&#10;                ) {&#10;                    Text(&quot;Continuar&quot;)&#10;                }&#10;            }&#10;        )&#10;    }&#10;&#10;    // Diálogo de información&#10;    if (showInfoDialog) {&#10;        AlertDialog(&#10;            onDismissRequest = { showInfoDialog = false },&#10;            title = {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Info,&#10;                        contentDescription = &quot;Información&quot;,&#10;                        tint = MaterialTheme.colorScheme.primary,&#10;                        modifier = Modifier.size(28.dp)&#10;                    )&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;                    Text(&#10;                        text = &quot;Información de Detección&quot;,&#10;                        fontSize = 20.sp,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                }&#10;            },&#10;            text = {&#10;                Column {&#10;                    Text(&#10;                        text = &quot;Letra: $vowel&quot;,&#10;                        fontSize = 16.sp,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = MaterialTheme.colorScheme.primary&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    Text(&#10;                        text = &quot;Estado: $detectionStatus&quot;,&#10;                        fontSize = 14.sp,&#10;                        color = MaterialTheme.colorScheme.onSurface&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    Text(&#10;                        text = &quot;Validación: ${when (validationResult) {&#10;                            is ValidationState.Detecting -&gt; &quot;Detectando...&quot;&#10;                            is ValidationState.Success -&gt; &quot;¡Correcto!&quot;&#10;                            is ValidationState.Error -&gt; (validationResult as ValidationState.Error).message&#10;                            is ValidationState.Waiting -&gt; &quot;Esperando seña...&quot;&#10;                        }}&quot;,&#10;                        fontSize = 14.sp,&#10;                        color = when (validationResult) {&#10;                            is ValidationState.Success -&gt; Color(0xFF4CAF50)&#10;                            is ValidationState.Error -&gt; Color(0xFFF44336)&#10;                            else -&gt; MaterialTheme.colorScheme.onSurface&#10;                        }&#10;                    )&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                    HorizontalDivider()&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                    Text(&#10;                        text = &quot; Instrucciones:&quot;,&#10;                        fontSize = 16.sp,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    Text(&#10;                        text = when (vowel.uppercase()) {&#10;                            &quot;A&quot; -&gt; &quot;Extiende el pulgar hacia afuera y cierra los demás dedos formando un puño&quot;&#10;                            &quot;E&quot; -&gt; &quot;Curva todos los dedos hacia la palma, con el pulgar cubriendo las puntas&quot;&#10;                            &quot;I&quot; -&gt; &quot;Extiende solo el meñique hacia arriba, mantén los demás dedos cerrados&quot;&#10;                            &quot;O&quot; -&gt; &quot;Forma un círculo con todos los dedos, juntando las puntas&quot;&#10;                            &quot;U&quot; -&gt; &quot;Extiende índice y meñique hacia arriba, cierra medio, anular y pulgar&quot;&#10;                            &quot;Z&quot; -&gt; &quot;Extiende solo el índice y traza una Z en el aire: línea horizontal → diagonal → línea horizontal&quot;&#10;                            &quot;AMIGO&quot; -&gt; &quot;Muy simple: muestra ambas manos, coloca una arriba y otra abajo, que estén cerca. ¡Eso es todo!&quot;&#10;                            else -&gt; &quot;Realiza la seña correspondiente seleccionada&quot;&#10;                        },&#10;                        fontSize = 14.sp,&#10;                        lineHeight = 20.sp&#10;                    )&#10;                }&#10;            },&#10;            confirmButton = {&#10;                Button(&#10;                    onClick = { showInfoDialog = false }&#10;                ) {&#10;                    Text(&quot;Entendido&quot;)&#10;                }&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun CameraPreviewWithValidation(&#10;    useFrontCamera: Boolean,&#10;    handDetector: HandDetector,&#10;    faceDetector: FaceDetector,&#10;    onImageDimensionsChanged: (Int, Int) -&gt; Unit&#10;) {&#10;    val lifecycleOwner = LocalLifecycleOwner.current&#10;    val cameraExecutor = remember { Executors.newSingleThreadExecutor() }&#10;&#10;    DisposableEffect(Unit) {&#10;        onDispose {&#10;            cameraExecutor.shutdown()&#10;        }&#10;    }&#10;&#10;    AndroidView(&#10;        factory = { ctx -&gt;&#10;            val previewView = PreviewView(ctx).apply {&#10;                layoutParams = ViewGroup.LayoutParams(&#10;                    ViewGroup.LayoutParams.MATCH_PARENT,&#10;                    ViewGroup.LayoutParams.MATCH_PARENT&#10;                )&#10;                scaleType = PreviewView.ScaleType.FIT_CENTER&#10;                implementationMode = PreviewView.ImplementationMode.COMPATIBLE&#10;            }&#10;&#10;            val cameraProviderFuture = ProcessCameraProvider.getInstance(ctx)&#10;            cameraProviderFuture.addListener({&#10;                val cameraProvider = cameraProviderFuture.get()&#10;&#10;                val preview = Preview.Builder()&#10;                    .setTargetRotation(previewView.display.rotation)&#10;                    .build()&#10;                    .also {&#10;                        it.setSurfaceProvider(previewView.surfaceProvider)&#10;                    }&#10;&#10;                val imageAnalysis = ImageAnalysis.Builder()&#10;                    .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)&#10;                    .setOutputImageFormat(ImageAnalysis.OUTPUT_IMAGE_FORMAT_RGBA_8888)&#10;                    .setTargetRotation(previewView.display.rotation)&#10;                    .build()&#10;                    .apply {&#10;                        setAnalyzer(cameraExecutor) { imageProxy -&gt;&#10;                            processImageProxyForValidation(&#10;                                imageProxy = imageProxy,&#10;                                handDetector = handDetector,&#10;                                faceDetector = faceDetector,&#10;                                onImageDimensionsChanged = onImageDimensionsChanged,&#10;                                isFrontCamera = useFrontCamera&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                val cameraSelector = if (useFrontCamera) {&#10;                    CameraSelector.DEFAULT_FRONT_CAMERA&#10;                } else {&#10;                    CameraSelector.DEFAULT_BACK_CAMERA&#10;                }&#10;&#10;                try {&#10;                    cameraProvider.unbindAll()&#10;                    cameraProvider.bindToLifecycle(&#10;                        lifecycleOwner,&#10;                        cameraSelector,&#10;                        preview,&#10;                        imageAnalysis&#10;                    )&#10;                } catch (e: Exception) {&#10;                    Log.e(&quot;VowelValidation&quot;, &quot;Camera binding failed&quot;, e)&#10;                }&#10;            }, ContextCompat.getMainExecutor(ctx))&#10;&#10;            previewView&#10;        },&#10;        modifier = Modifier.fillMaxSize(),&#10;        update = { _ -&gt;&#10;            // Actualizar cuando cambie la cámara&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun PermissionRequestCard(onRequestPermission: () -&gt; Unit) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .aspectRatio(3f / 4f),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.fillMaxSize(),&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Center&#10;        ) {&#10;            Text(&#10;                text = &quot;&quot;,&#10;                fontSize = 64.sp&#10;            )&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            Text(&#10;                text = &quot;Permiso de cámara requerido&quot;,&#10;                fontSize = 16.sp,&#10;                fontWeight = FontWeight.Bold,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            Button(&#10;                onClick = onRequestPermission,&#10;                colors = ButtonDefaults.buttonColors(&#10;                    containerColor = MaterialTheme.colorScheme.primary&#10;                )&#10;            ) {&#10;                Text(&quot;Solicitar permiso&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;private fun processImageProxyForValidation(&#10;    imageProxy: ImageProxy,&#10;    handDetector: HandDetector,&#10;    faceDetector: FaceDetector,&#10;    onImageDimensionsChanged: (Int, Int) -&gt; Unit,&#10;    isFrontCamera: Boolean = true&#10;) {&#10;    val bitmap = imageProxy.toBitmap()&#10;    val rotationDegrees = imageProxy.imageInfo.rotationDegrees&#10;&#10;    // Rotar el bitmap según la rotación del sensor&#10;    val rotatedBitmap = if (rotationDegrees != 0) {&#10;        val matrix = Matrix()&#10;        matrix.postRotate(rotationDegrees.toFloat())&#10;        if (isFrontCamera) {&#10;            matrix.postScale(-1f, 1f)&#10;        }&#10;&#10;        val rotated = Bitmap.createBitmap(&#10;            bitmap,&#10;            0,&#10;            0,&#10;            bitmap.width,&#10;            bitmap.height,&#10;            matrix,&#10;            true&#10;        )&#10;&#10;        if (rotated != bitmap) {&#10;            bitmap.recycle()&#10;        }&#10;&#10;        rotated&#10;    } else {&#10;        if (isFrontCamera) {&#10;            val matrix = Matrix()&#10;            matrix.postScale(-1f, 1f)&#10;            val flipped = Bitmap.createBitmap(&#10;                bitmap,&#10;                0,&#10;                0,&#10;                bitmap.width,&#10;                bitmap.height,&#10;                matrix,&#10;                true&#10;            )&#10;            if (flipped != bitmap) {&#10;                bitmap.recycle()&#10;            }&#10;            flipped&#10;        } else {&#10;            bitmap&#10;        }&#10;    }&#10;&#10;    val frameTime = System.currentTimeMillis()&#10;&#10;    onImageDimensionsChanged(rotatedBitmap.width, rotatedBitmap.height)&#10;&#10;    if (handDetector.isReady()) {&#10;        handDetector.detectAsync(rotatedBitmap, frameTime)&#10;    }&#10;&#10;    if (faceDetector.isReady()) {&#10;        faceDetector.detectAsync(rotatedBitmap, frameTime)&#10;    }&#10;&#10;    imageProxy.close()&#10;}&#10;&#10;private fun validateVowelSign(&#10;    handResult: HandLandmarkerResult,&#10;    vowel: String,&#10;    validator: VowelSignValidator&#10;): ValidationState {&#10;    return try {&#10;        // Manejo especial para &quot;Amigo&quot; (requiere dos manos)&#10;        if (vowel.uppercase() == &quot;AMIGO&quot;) {&#10;            val amigoResult = validator.validateSignAmigo(handResult)&#10;            return if (amigoResult.isValid) {&#10;                ValidationState.Success&#10;            } else {&#10;                ValidationState.Error(amigoResult.message)&#10;            }&#10;        }&#10;&#10;        if (handResult.landmarks().isEmpty()) {&#10;            return ValidationState.Waiting&#10;        }&#10;&#10;&#10;        // Manejo especial para la letra Z (requiere movimiento)&#10;        if (vowel.uppercase() == &quot;Z&quot;) {&#10;            val zResult = validator.validateLetterZ(handResult)&#10;            return if (zResult.isValid) {&#10;                ValidationState.Success&#10;            } else {&#10;                ValidationState.Error(zResult.message)&#10;            }&#10;        }&#10;&#10;        // Validación para las demás letras (estáticas)&#10;        val isValid = when (vowel.uppercase()) {&#10;            &quot;A&quot; -&gt; validator.validateLetterA(handResult)&#10;            &quot;E&quot; -&gt; validator.validateLetterE(handResult)&#10;            &quot;I&quot; -&gt; validator.validateLetterI(handResult)&#10;            &quot;O&quot; -&gt; validator.validateLetterO(handResult)&#10;            &quot;U&quot; -&gt; validator.validateLetterU(handResult)&#10;            else -&gt; false&#10;        }&#10;&#10;        if (isValid) {&#10;            ValidationState.Success&#10;        } else {&#10;            ValidationState.Error(&quot;Ajusta la posición de tus dedos&quot;)&#10;        }&#10;    } catch (e: Exception) {&#10;        ValidationState.Error(&quot;Error en la validación&quot;)&#10;    }&#10;}&#10;&#10;sealed class ValidationState {&#10;    object Detecting : ValidationState()&#10;    object Waiting : ValidationState()&#10;    object Success : ValidationState()&#10;    data class Error(val message: String) : ValidationState()&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.ecohand.presentation.senas&#10;&#10;import android.Manifest&#10;import android.content.pm.PackageManager&#10;import android.graphics.Bitmap&#10;import android.graphics.Matrix&#10;import android.util.Log&#10;import android.view.ViewGroup&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.camera.core.CameraSelector&#10;import androidx.camera.core.ImageAnalysis&#10;import androidx.camera.core.ImageProxy&#10;import androidx.camera.core.Preview&#10;import androidx.camera.lifecycle.ProcessCameraProvider&#10;import androidx.camera.view.PreviewView&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Check&#10;import androidx.compose.material.icons.filled.Refresh&#10;import androidx.compose.material.icons.filled.Info&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalLifecycleOwner&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;import androidx.core.content.ContextCompat&#10;import com.example.ecohand.ml.FaceDetector&#10;import com.example.ecohand.ml.HandDetector&#10;import com.example.ecohand.ml.VowelSignValidator&#10;import com.example.ecohand.presentation.components.DetectionOverlay&#10;import com.google.mediapipe.tasks.vision.core.RunningMode&#10;import com.google.mediapipe.tasks.vision.facelandmarker.FaceLandmarkerResult&#10;import com.google.mediapipe.tasks.vision.handlandmarker.HandLandmarkerResult&#10;import java.util.concurrent.Executors&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun VowelValidationScreen(&#10;    vowel: String,&#10;    onNavigateBack: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;&#10;    var hasCameraPermission by remember {&#10;        mutableStateOf(&#10;            ContextCompat.checkSelfPermission(&#10;                context,&#10;                Manifest.permission.CAMERA&#10;            ) == PackageManager.PERMISSION_GRANTED&#10;        )&#10;    }&#10;&#10;    val launcher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.RequestPermission(),&#10;        onResult = { granted -&gt;&#10;            hasCameraPermission = granted&#10;        }&#10;    )&#10;&#10;    var useFrontCamera by remember { mutableStateOf(true) }&#10;    var handResults by remember { mutableStateOf&lt;HandLandmarkerResult?&gt;(null) }&#10;    var faceResults by remember { mutableStateOf&lt;FaceLandmarkerResult?&gt;(null) }&#10;    var imageWidth by remember { mutableStateOf(640) }&#10;    var imageHeight by remember { mutableStateOf(480) }&#10;    var detectionStatus by remember { mutableStateOf(&quot;Inicializando...&quot;) }&#10;    var validationResult by remember { mutableStateOf&lt;ValidationState&gt;(ValidationState.Detecting) }&#10;    var showSuccessDialog by remember { mutableStateOf(false) }&#10;    var showInfoDialog by remember { mutableStateOf(false) }&#10;&#10;    // Detectores y validador&#10;    val handDetector = remember {&#10;        HandDetector(&#10;            context = context,&#10;            runningMode = RunningMode.LIVE_STREAM,&#10;            maxNumHands = 2 // Detectar hasta 2 manos (necesario para señas como &quot;Amigo&quot;)&#10;        )&#10;    }&#10;&#10;    val faceDetector = remember {&#10;        FaceDetector(&#10;            context = context,&#10;            runningMode = RunningMode.LIVE_STREAM,&#10;            maxNumFaces = 1&#10;        )&#10;    }&#10;&#10;    val vowelValidator = remember { VowelSignValidator() }&#10;&#10;    // Inicializar detectores&#10;    LaunchedEffect(Unit) {&#10;        if (!hasCameraPermission) {&#10;            launcher.launch(Manifest.permission.CAMERA)&#10;        }&#10;&#10;        val handInit = handDetector.initialize { result, _ -&gt;&#10;            handResults = result&#10;            // Validar la seña automáticamente&#10;            validationResult = validateVowelSign(result, vowel, vowelValidator)&#10;        }&#10;&#10;        val faceInit = faceDetector.initialize { result, _ -&gt;&#10;            faceResults = result&#10;        }&#10;&#10;        detectionStatus = when {&#10;            handInit &amp;&amp; faceInit -&gt; &quot;✓ Detectores listos&quot;&#10;            handInit -&gt; &quot;⚠ Solo manos listo&quot;&#10;            faceInit -&gt; &quot;⚠ Solo rostro listo&quot;&#10;            else -&gt; &quot;✗ Error al inicializar&quot;&#10;        }&#10;    }&#10;&#10;    // Mostrar diálogo de éxito cuando se valide correctamente&#10;    LaunchedEffect(validationResult) {&#10;        if (validationResult is ValidationState.Success) {&#10;            showSuccessDialog = true&#10;        }&#10;    }&#10;&#10;    // Limpiar recursos&#10;    DisposableEffect(Unit) {&#10;        onDispose {&#10;            handDetector.close()&#10;            faceDetector.close()&#10;            // Limpiar trayectorias de letras con movimiento&#10;            vowelValidator.resetZTrajectory()&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = {&#10;                    Text(&#10;                        text = &quot;Validar: $vowel&quot;,&#10;                        fontWeight = FontWeight.Bold,&#10;                        fontSize = 18.sp&#10;                    )&#10;                },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onNavigateBack) {&#10;                        Icon(&#10;                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                            contentDescription = &quot;Volver&quot;&#10;                        )&#10;                    }&#10;                },&#10;                actions = {&#10;                    // Botón de información&#10;                    IconButton(onClick = { showInfoDialog = true }) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Info,&#10;                            contentDescription = &quot;Ver información&quot;&#10;                        )&#10;                    }&#10;                    // Botón para cambiar cámara&#10;                    IconButton(onClick = { useFrontCamera = !useFrontCamera }) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Refresh,&#10;                            contentDescription = &quot;Cambiar cámara&quot;&#10;                        )&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = MaterialTheme.colorScheme.primary,&#10;                    titleContentColor = MaterialTheme.colorScheme.onPrimary,&#10;                    navigationIconContentColor = MaterialTheme.colorScheme.onPrimary,&#10;                    actionIconContentColor = MaterialTheme.colorScheme.onPrimary&#10;                )&#10;            )&#10;        }&#10;    ) { paddingValues -&gt;&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues)&#10;                .background(MaterialTheme.colorScheme.background)&#10;        ) {&#10;            // Vista de cámara con overlay ocupando todo el espacio&#10;            if (hasCameraPermission) {&#10;                // Cámara con key para forzar recomposición al cambiar de cámara&#10;                key(useFrontCamera) {&#10;                    CameraPreviewWithValidation(&#10;                        useFrontCamera = useFrontCamera,&#10;                        handDetector = handDetector,&#10;                        faceDetector = faceDetector,&#10;                        onImageDimensionsChanged = { width, height -&gt;&#10;                            imageWidth = width&#10;                            imageHeight = height&#10;                        }&#10;                    )&#10;                }&#10;&#10;                // Overlay de detecciones&#10;                DetectionOverlay(&#10;                    handResults = handResults,&#10;                    faceResults = faceResults,&#10;                    imageWidth = imageWidth,&#10;                    imageHeight = imageHeight,&#10;                    modifier = Modifier.fillMaxSize()&#10;                )&#10;&#10;                // Overlay de estado en la parte superior (texto sin fondo)&#10;                Column(&#10;                    modifier = Modifier&#10;                        .align(Alignment.TopCenter)&#10;                        .fillMaxWidth()&#10;                        .padding(16.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    // Estado de validación (texto con sombra para visibilidad)&#10;                    Text(&#10;                        text = when (validationResult) {&#10;                            is ValidationState.Detecting -&gt; &quot; Detectando...&quot;&#10;                            is ValidationState.Success -&gt; &quot;✅ ¡Correcto!&quot;&#10;                            is ValidationState.Error -&gt; &quot;❌ ${(validationResult as ValidationState.Error).message}&quot;&#10;                            is ValidationState.Waiting -&gt; &quot;⏳ Esperando seña...&quot;&#10;                        },&#10;                        fontSize = 20.sp,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = when (validationResult) {&#10;                            is ValidationState.Success -&gt; Color(0xFF4CAF50)&#10;                            is ValidationState.Error -&gt; Color(0xFFF44336)&#10;                            else -&gt; Color.White&#10;                        },&#10;                        style = androidx.compose.ui.text.TextStyle(&#10;                            shadow = androidx.compose.ui.graphics.Shadow(&#10;                                color = Color.Black,&#10;                                offset = androidx.compose.ui.geometry.Offset(2f, 2f),&#10;                                blurRadius = 4f&#10;                            )&#10;                        ),&#10;                        textAlign = TextAlign.Center&#10;                    )&#10;                }&#10;            } else {&#10;                PermissionRequestCard(onRequestPermission = {&#10;                    launcher.launch(Manifest.permission.CAMERA)&#10;                })&#10;            }&#10;        }&#10;    }&#10;&#10;    // Diálogo de éxito&#10;    if (showSuccessDialog) {&#10;        AlertDialog(&#10;            onDismissRequest = { },&#10;            title = {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    horizontalArrangement = Arrangement.Center,&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Check,&#10;                        contentDescription = &quot;Éxito&quot;,&#10;                        tint = Color(0xFF4CAF50),&#10;                        modifier = Modifier.size(32.dp)&#10;                    )&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;                    Text(&#10;                        text = &quot;¡Correcto!&quot;,&#10;                        fontSize = 24.sp,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = Color(0xFF4CAF50)&#10;                    )&#10;                }&#10;            },&#10;            text = {&#10;                Column(&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    Text(&#10;                        text = &quot;&quot;,&#10;                        fontSize = 48.sp&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    Text(&#10;                        text = &quot;Has realizado correctamente la seña: $vowel&quot;,&#10;                        textAlign = TextAlign.Center,&#10;                        fontSize = 16.sp&#10;                    )&#10;                }&#10;            },&#10;            confirmButton = {&#10;                Button(&#10;                    onClick = {&#10;                        showSuccessDialog = false&#10;                        onNavigateBack()&#10;                    },&#10;                    colors = ButtonDefaults.buttonColors(&#10;                        containerColor = Color(0xFF4CAF50)&#10;                    )&#10;                ) {&#10;                    Text(&quot;Continuar&quot;)&#10;                }&#10;            }&#10;        )&#10;    }&#10;&#10;    // Diálogo de información&#10;    if (showInfoDialog) {&#10;        AlertDialog(&#10;            onDismissRequest = { showInfoDialog = false },&#10;            title = {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Info,&#10;                        contentDescription = &quot;Información&quot;,&#10;                        tint = MaterialTheme.colorScheme.primary,&#10;                        modifier = Modifier.size(28.dp)&#10;                    )&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;                    Text(&#10;                        text = &quot;Información de Detección&quot;,&#10;                        fontSize = 20.sp,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                }&#10;            },&#10;            text = {&#10;                Column {&#10;                    Text(&#10;                        text = &quot;Letra: $vowel&quot;,&#10;                        fontSize = 16.sp,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = MaterialTheme.colorScheme.primary&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    Text(&#10;                        text = &quot;Estado: $detectionStatus&quot;,&#10;                        fontSize = 14.sp,&#10;                        color = MaterialTheme.colorScheme.onSurface&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    Text(&#10;                        text = &quot;Validación: ${when (validationResult) {&#10;                            is ValidationState.Detecting -&gt; &quot;Detectando...&quot;&#10;                            is ValidationState.Success -&gt; &quot;¡Correcto!&quot;&#10;                            is ValidationState.Error -&gt; (validationResult as ValidationState.Error).message&#10;                            is ValidationState.Waiting -&gt; &quot;Esperando seña...&quot;&#10;                        }}&quot;,&#10;                        fontSize = 14.sp,&#10;                        color = when (validationResult) {&#10;                            is ValidationState.Success -&gt; Color(0xFF4CAF50)&#10;                            is ValidationState.Error -&gt; Color(0xFFF44336)&#10;                            else -&gt; MaterialTheme.colorScheme.onSurface&#10;                        }&#10;                    )&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                    HorizontalDivider()&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                    Text(&#10;                        text = &quot; Instrucciones:&quot;,&#10;                        fontSize = 16.sp,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    Text(&#10;                        text = when (vowel.uppercase()) {&#10;                            &quot;A&quot; -&gt; &quot;Extiende el pulgar hacia afuera y cierra los demás dedos formando un puño&quot;&#10;                            &quot;E&quot; -&gt; &quot;Curva todos los dedos hacia la palma, con el pulgar cubriendo las puntas&quot;&#10;                            &quot;I&quot; -&gt; &quot;Extiende solo el meñique hacia arriba, mantén los demás dedos cerrados&quot;&#10;                            &quot;O&quot; -&gt; &quot;Forma un círculo con todos los dedos, juntando las puntas&quot;&#10;                            &quot;U&quot; -&gt; &quot;Extiende índice y meñique hacia arriba, cierra medio, anular y pulgar&quot;&#10;                            &quot;Z&quot; -&gt; &quot;Extiende solo el índice y traza una Z en el aire: línea horizontal → diagonal → línea horizontal&quot;&#10;                            &quot;AMIGO&quot; -&gt; &quot;Muy simple: muestra ambas manos, coloca una arriba y otra abajo, que estén cerca. ¡Eso es todo!&quot;&#10;                            &quot;0&quot; -&gt; &quot;Forma un círculo con todos los dedos curvados, juntando las puntas de los dedos (índice, medio, anular y meñique) con la punta del pulgar&quot;&#10;                            &quot;1&quot; -&gt; &quot;Extiende solo el dedo índice hacia arriba, mantén los demás dedos cerrados&quot;&#10;                            &quot;2&quot; -&gt; &quot;Extiende los dedos índice y medio hacia arriba formando una V, cierra el pulgar, anular y meñique&quot;&#10;                            &quot;3&quot; -&gt; &quot;Extiende los dedos índice, medio y anular hacia arriba, mantén cerrados el pulgar y meñique&quot;&#10;                            &quot;4&quot; -&gt; &quot;Extiende los cuatro dedos (índice, medio, anular y meñique) hacia arriba, dobla el pulgar hacia la palma&quot;&#10;                            &quot;5&quot; -&gt; &quot;Abre completamente la mano con todos los dedos extendidos y separados&quot;&#10;                            else -&gt; &quot;Realiza la seña correspondiente seleccionada&quot;&#10;                        },&#10;                        fontSize = 14.sp,&#10;                        lineHeight = 20.sp&#10;                    )&#10;                }&#10;            },&#10;            confirmButton = {&#10;                Button(&#10;                    onClick = { showInfoDialog = false }&#10;                ) {&#10;                    Text(&quot;Entendido&quot;)&#10;                }&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun CameraPreviewWithValidation(&#10;    useFrontCamera: Boolean,&#10;    handDetector: HandDetector,&#10;    faceDetector: FaceDetector,&#10;    onImageDimensionsChanged: (Int, Int) -&gt; Unit&#10;) {&#10;    val lifecycleOwner = LocalLifecycleOwner.current&#10;    val cameraExecutor = remember { Executors.newSingleThreadExecutor() }&#10;&#10;    DisposableEffect(Unit) {&#10;        onDispose {&#10;            cameraExecutor.shutdown()&#10;        }&#10;    }&#10;&#10;    AndroidView(&#10;        factory = { ctx -&gt;&#10;            val previewView = PreviewView(ctx).apply {&#10;                layoutParams = ViewGroup.LayoutParams(&#10;                    ViewGroup.LayoutParams.MATCH_PARENT,&#10;                    ViewGroup.LayoutParams.MATCH_PARENT&#10;                )&#10;                scaleType = PreviewView.ScaleType.FIT_CENTER&#10;                implementationMode = PreviewView.ImplementationMode.COMPATIBLE&#10;            }&#10;&#10;            val cameraProviderFuture = ProcessCameraProvider.getInstance(ctx)&#10;            cameraProviderFuture.addListener({&#10;                val cameraProvider = cameraProviderFuture.get()&#10;&#10;                val preview = Preview.Builder()&#10;                    .setTargetRotation(previewView.display.rotation)&#10;                    .build()&#10;                    .also {&#10;                        it.setSurfaceProvider(previewView.surfaceProvider)&#10;                    }&#10;&#10;                val imageAnalysis = ImageAnalysis.Builder()&#10;                    .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)&#10;                    .setOutputImageFormat(ImageAnalysis.OUTPUT_IMAGE_FORMAT_RGBA_8888)&#10;                    .setTargetRotation(previewView.display.rotation)&#10;                    .build()&#10;                    .apply {&#10;                        setAnalyzer(cameraExecutor) { imageProxy -&gt;&#10;                            processImageProxyForValidation(&#10;                                imageProxy = imageProxy,&#10;                                handDetector = handDetector,&#10;                                faceDetector = faceDetector,&#10;                                onImageDimensionsChanged = onImageDimensionsChanged,&#10;                                isFrontCamera = useFrontCamera&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                val cameraSelector = if (useFrontCamera) {&#10;                    CameraSelector.DEFAULT_FRONT_CAMERA&#10;                } else {&#10;                    CameraSelector.DEFAULT_BACK_CAMERA&#10;                }&#10;&#10;                try {&#10;                    cameraProvider.unbindAll()&#10;                    cameraProvider.bindToLifecycle(&#10;                        lifecycleOwner,&#10;                        cameraSelector,&#10;                        preview,&#10;                        imageAnalysis&#10;                    )&#10;                } catch (e: Exception) {&#10;                    Log.e(&quot;VowelValidation&quot;, &quot;Camera binding failed&quot;, e)&#10;                }&#10;            }, ContextCompat.getMainExecutor(ctx))&#10;&#10;            previewView&#10;        },&#10;        modifier = Modifier.fillMaxSize(),&#10;        update = { _ -&gt;&#10;            // Actualizar cuando cambie la cámara&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun PermissionRequestCard(onRequestPermission: () -&gt; Unit) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .aspectRatio(3f / 4f),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.fillMaxSize(),&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Center&#10;        ) {&#10;            Text(&#10;                text = &quot;&quot;,&#10;                fontSize = 64.sp&#10;            )&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            Text(&#10;                text = &quot;Permiso de cámara requerido&quot;,&#10;                fontSize = 16.sp,&#10;                fontWeight = FontWeight.Bold,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            Button(&#10;                onClick = onRequestPermission,&#10;                colors = ButtonDefaults.buttonColors(&#10;                    containerColor = MaterialTheme.colorScheme.primary&#10;                )&#10;            ) {&#10;                Text(&quot;Solicitar permiso&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;private fun processImageProxyForValidation(&#10;    imageProxy: ImageProxy,&#10;    handDetector: HandDetector,&#10;    faceDetector: FaceDetector,&#10;    onImageDimensionsChanged: (Int, Int) -&gt; Unit,&#10;    isFrontCamera: Boolean = true&#10;) {&#10;    val bitmap = imageProxy.toBitmap()&#10;    val rotationDegrees = imageProxy.imageInfo.rotationDegrees&#10;&#10;    // Rotar el bitmap según la rotación del sensor&#10;    val rotatedBitmap = if (rotationDegrees != 0) {&#10;        val matrix = Matrix()&#10;        matrix.postRotate(rotationDegrees.toFloat())&#10;        if (isFrontCamera) {&#10;            matrix.postScale(-1f, 1f)&#10;        }&#10;&#10;        val rotated = Bitmap.createBitmap(&#10;            bitmap,&#10;            0,&#10;            0,&#10;            bitmap.width,&#10;            bitmap.height,&#10;            matrix,&#10;            true&#10;        )&#10;&#10;        if (rotated != bitmap) {&#10;            bitmap.recycle()&#10;        }&#10;&#10;        rotated&#10;    } else {&#10;        if (isFrontCamera) {&#10;            val matrix = Matrix()&#10;            matrix.postScale(-1f, 1f)&#10;            val flipped = Bitmap.createBitmap(&#10;                bitmap,&#10;                0,&#10;                0,&#10;                bitmap.width,&#10;                bitmap.height,&#10;                matrix,&#10;                true&#10;            )&#10;            if (flipped != bitmap) {&#10;                bitmap.recycle()&#10;            }&#10;            flipped&#10;        } else {&#10;            bitmap&#10;        }&#10;    }&#10;&#10;    val frameTime = System.currentTimeMillis()&#10;&#10;    onImageDimensionsChanged(rotatedBitmap.width, rotatedBitmap.height)&#10;&#10;    if (handDetector.isReady()) {&#10;        handDetector.detectAsync(rotatedBitmap, frameTime)&#10;    }&#10;&#10;    if (faceDetector.isReady()) {&#10;        faceDetector.detectAsync(rotatedBitmap, frameTime)&#10;    }&#10;&#10;    imageProxy.close()&#10;}&#10;&#10;private fun validateVowelSign(&#10;    handResult: HandLandmarkerResult,&#10;    vowel: String,&#10;    validator: VowelSignValidator&#10;): ValidationState {&#10;    return try {&#10;        // Manejo especial para &quot;Amigo&quot; (requiere dos manos)&#10;        if (vowel.uppercase() == &quot;AMIGO&quot;) {&#10;            val amigoResult = validator.validateSignAmigo(handResult)&#10;            return if (amigoResult.isValid) {&#10;                ValidationState.Success&#10;            } else {&#10;                ValidationState.Error(amigoResult.message)&#10;            }&#10;        }&#10;&#10;        if (handResult.landmarks().isEmpty()) {&#10;            return ValidationState.Waiting&#10;        }&#10;&#10;&#10;        // Manejo especial para la letra Z (requiere movimiento)&#10;        if (vowel.uppercase() == &quot;Z&quot;) {&#10;            val zResult = validator.validateLetterZ(handResult)&#10;            return if (zResult.isValid) {&#10;                ValidationState.Success&#10;            } else {&#10;                ValidationState.Error(zResult.message)&#10;            }&#10;        }&#10;&#10;        // Validación para las demás letras (estáticas)&#10;        val isValid = when (vowel.uppercase()) {&#10;            &quot;A&quot; -&gt; validator.validateLetterA(handResult)&#10;            &quot;E&quot; -&gt; validator.validateLetterE(handResult)&#10;            &quot;I&quot; -&gt; validator.validateLetterI(handResult)&#10;            &quot;O&quot; -&gt; validator.validateLetterO(handResult)&#10;            &quot;U&quot; -&gt; validator.validateLetterU(handResult)&#10;            &quot;0&quot; -&gt; validator.validateNumber0(handResult)&#10;            &quot;1&quot; -&gt; validator.validateNumber1(handResult)&#10;            &quot;2&quot; -&gt; validator.validateNumber2(handResult)&#10;            &quot;3&quot; -&gt; validator.validateNumber3(handResult)&#10;            &quot;4&quot; -&gt; validator.validateNumber4(handResult)&#10;            &quot;5&quot; -&gt; validator.validateNumber5(handResult)&#10;            else -&gt; false&#10;        }&#10;&#10;        if (isValid) {&#10;            ValidationState.Success&#10;        } else {&#10;            ValidationState.Error(&quot;Ajusta la posición de tus dedos&quot;)&#10;        }&#10;    } catch (e: Exception) {&#10;        ValidationState.Error(&quot;Error en la validación&quot;)&#10;    }&#10;}&#10;&#10;sealed class ValidationState {&#10;    object Detecting : ValidationState()&#10;    object Waiting : ValidationState()&#10;    object Success : ValidationState()&#10;    data class Error(val message: String) : ValidationState()&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>