<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/ecohand/data/session/LeccionValidacionState.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/ecohand/data/session/LeccionValidacionState.kt" />
              <option name="updatedContent" value="package com.example.ecohand.data.session&#10;&#10;object LeccionValidacionState {&#10;    private val senasCompletadas = mutableMapOf&lt;Pair&lt;Int, String&gt;, Boolean&gt;()&#10;    &#10;    fun marcarSenaCompletada(leccionId: Int, letra: String) {&#10;        senasCompletadas[Pair(leccionId, letra)] = true&#10;    }&#10;    &#10;    fun estaSenaCompletada(leccionId: Int, letra: String): Boolean {&#10;        return senasCompletadas[Pair(leccionId, letra)] ?: false&#10;    }&#10;    &#10;    fun limpiarLeccion(leccionId: Int) {&#10;        senasCompletadas.keys.removeAll { it.first == leccionId }&#10;    }&#10;    &#10;    fun limpiarTodo() {&#10;        senasCompletadas.clear()&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/ecohand/navigation/Screen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/ecohand/navigation/Screen.kt" />
              <option name="originalContent" value="package com.example.ecohand.navigation&#10;&#10;sealed class Screen(val route: String) {&#10;    object Splash : Screen(&quot;splash&quot;)&#10;    object Login : Screen(&quot;login&quot;)&#10;    object Home : Screen(&quot;home&quot;)&#10;    object Inicio : Screen(&quot;inicio&quot;)&#10;    object Lecciones : Screen(&quot;lecciones&quot;)&#10;    object LeccionDetalle : Screen(&quot;leccion_detalle/{leccionId}&quot;) {&#10;        fun createRoute(leccionId: Int) = &quot;leccion_detalle/$leccionId&quot;&#10;    }&#10;    object LeccionPractica : Screen(&quot;leccion_practica/{leccionId}&quot;) {&#10;        fun createRoute(leccionId: Int) = &quot;leccion_practica/$leccionId&quot;&#10;    }&#10;    object Progreso : Screen(&quot;progreso&quot;)&#10;    object Juegos : Screen(&quot;juegos&quot;)&#10;    object Perfil : Screen(&quot;perfil&quot;)&#10;    &#10;    // Pantallas de perfil&#10;    object Configuracion : Screen(&quot;configuracion&quot;)&#10;    object MisLogros : Screen(&quot;mis_logros&quot;)&#10;    object DiccionarioLSP : Screen(&quot;diccionario_lsp&quot;)&#10;    object CompartirApp : Screen(&quot;compartir_app&quot;)&#10;    object AyudaSoporte : Screen(&quot;ayuda_soporte&quot;)&#10;&#10;    // Pantalla de prueba de detección&#10;    object DetectionTest : Screen(&quot;detection_test&quot;)&#10;&#10;    // Pantallas de validación de señas&#10;    object CategorySelection : Screen(&quot;category_selection&quot;)&#10;    object VowelSelection : Screen(&quot;vowel_selection/{category}&quot;) {&#10;        fun createRoute(category: String) = &quot;vowel_selection/$category&quot;&#10;    }&#10;    object VowelValidation : Screen(&quot;vowel_validation/{vowel}?leccionId={leccionId}&quot;) {&#10;        fun createRoute(vowel: String, leccionId: Int? = null): String {&#10;            val leccionIdParam = leccionId ?: -1&#10;            return &quot;vowel_validation/$vowel?leccionId=$leccionIdParam&quot;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.ecohand.navigation&#10;&#10;sealed class Screen(val route: String) {&#10;    object Splash : Screen(&quot;splash&quot;)&#10;    object Login : Screen(&quot;login&quot;)&#10;    object Home : Screen(&quot;home&quot;)&#10;    object Inicio : Screen(&quot;inicio&quot;)&#10;    object Lecciones : Screen(&quot;lecciones&quot;)&#10;    object LeccionDetalle : Screen(&quot;leccion_detalle/{leccionId}&quot;) {&#10;        fun createRoute(leccionId: Int) = &quot;leccion_detalle/$leccionId&quot;&#10;    }&#10;    object LeccionPractica : Screen(&quot;leccion_practica/{leccionId}&quot;) {&#10;        fun createRoute(leccionId: Int) = &quot;leccion_practica/$leccionId&quot;&#10;    }&#10;    object LeccionListaValidacion : Screen(&quot;leccion_lista_validacion/{leccionId}&quot;) {&#10;        fun createRoute(leccionId: Int) = &quot;leccion_lista_validacion/$leccionId&quot;&#10;    }&#10;    object Progreso : Screen(&quot;progreso&quot;)&#10;    object Juegos : Screen(&quot;juegos&quot;)&#10;    object Perfil : Screen(&quot;perfil&quot;)&#10;    &#10;    // Pantallas de perfil&#10;    object Configuracion : Screen(&quot;configuracion&quot;)&#10;    object MisLogros : Screen(&quot;mis_logros&quot;)&#10;    object DiccionarioLSP : Screen(&quot;diccionario_lsp&quot;)&#10;    object CompartirApp : Screen(&quot;compartir_app&quot;)&#10;    object AyudaSoporte : Screen(&quot;ayuda_soporte&quot;)&#10;&#10;    // Pantalla de prueba de detección&#10;    object DetectionTest : Screen(&quot;detection_test&quot;)&#10;&#10;    // Pantallas de validación de señas&#10;    object CategorySelection : Screen(&quot;category_selection&quot;)&#10;    object VowelSelection : Screen(&quot;vowel_selection/{category}&quot;) {&#10;        fun createRoute(category: String) = &quot;vowel_selection/$category&quot;&#10;    }&#10;    object VowelValidation : Screen(&quot;vowel_validation/{vowel}?leccionId={leccionId}&quot;) {&#10;        fun createRoute(vowel: String, leccionId: Int? = null): String {&#10;            val leccionIdParam = leccionId ?: -1&#10;            return &quot;vowel_validation/$vowel?leccionId=$leccionIdParam&quot;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/ecohand/presentation/lecciones/LeccionListaValidacionScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/ecohand/presentation/lecciones/LeccionListaValidacionScreen.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.example.ecohand.presentation.lecciones&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Check&#10;import androidx.compose.material.icons.filled.PlayArrow&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.example.ecohand.data.local.database.EcoHandDatabase&#10;import com.example.ecohand.data.repository.LeccionRepository&#10;import com.example.ecohand.data.session.UserSession&#10;import kotlinx.coroutines.launch&#10;&#10;data class SenaItem(&#10;    val letra: String,&#10;    val descripcion: String,&#10;    var completada: Boolean = false&#10;)&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun LeccionListaValidacionScreen(&#10;    leccionId: Int,&#10;    senasAValidar: List&lt;SenaItem&gt;,&#10;    onNavigateBack: () -&gt; Unit,&#10;    onNavigateToValidacion: (String, Int) -&gt; Unit,&#10;    onLeccionCompletada: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    // Inicializar señas con su estado guardado&#10;    var senas by remember { &#10;        mutableStateOf(senasAValidar.map { sena -&gt;&#10;            sena.copy(completada = com.example.ecohand.data.session.LeccionValidacionState.estaSenaCompletada(leccionId, sena.letra))&#10;        })&#10;    }&#10;    var showCompletedDialog by remember { mutableStateOf(false) }&#10;    &#10;    // Actualizar señas cuando regresamos de la validación&#10;    LaunchedEffect(Unit) {&#10;        // Actualizar estado de señas cada vez que entramos a la pantalla&#10;        senas = senasAValidar.map { sena -&gt;&#10;            sena.copy(completada = com.example.ecohand.data.session.LeccionValidacionState.estaSenaCompletada(leccionId, sena.letra))&#10;        }&#10;    }&#10;    &#10;    // Limpiar estado cuando salimos de la pantalla&#10;    DisposableEffect(Unit) {&#10;        onDispose {&#10;            // Si todas están completadas, limpiar el estado de esta lección&#10;            if (senas.all { it.completada }) {&#10;                com.example.ecohand.data.session.LeccionValidacionState.limpiarLeccion(leccionId)&#10;            }&#10;        }&#10;    }&#10;    &#10;    val scope = rememberCoroutineScope()&#10;    val database = remember { EcoHandDatabase.getDatabase(context) }&#10;    val leccionRepository = remember {&#10;        LeccionRepository(&#10;            database.leccionDao(),&#10;            database.progresoLeccionDao(),&#10;            database.estadisticasUsuarioDao()&#10;        )&#10;    }&#10;    val userSession = remember { UserSession.getInstance(context) }&#10;&#10;    // Calcular progreso&#10;    val senasCompletadas = senas.count { it.completada }&#10;    val senasTotal = senas.size&#10;    val progreso = if (senasTotal &gt; 0) senasCompletadas.toFloat() / senasTotal.toFloat() else 0f&#10;    val todasCompletadas = senasCompletadas == senasTotal&#10;&#10;    // Verificar si se completaron todas las señas&#10;    LaunchedEffect(todasCompletadas) {&#10;        if (todasCompletadas &amp;&amp; senasTotal &gt; 0 &amp;&amp; !showCompletedDialog) {&#10;            // Marcar lección como completada en BD&#10;            scope.launch {&#10;                try {&#10;                    val usuarioId = userSession.getUserId()&#10;                    leccionRepository.completarLeccion(usuarioId, leccionId)&#10;                    showCompletedDialog = true&#10;                } catch (e: Exception) {&#10;                    showCompletedDialog = true&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = {&#10;                    Column {&#10;                        Text(&#10;                            text = &quot;Práctica de Lección&quot;,&#10;                            fontWeight = FontWeight.Bold,&#10;                            fontSize = 18.sp&#10;                        )&#10;                        Text(&#10;                            text = &quot;$senasCompletadas de $senasTotal señas completadas&quot;,&#10;                            fontSize = 12.sp,&#10;                            color = MaterialTheme.colorScheme.onPrimary.copy(alpha = 0.8f)&#10;                        )&#10;                    }&#10;                },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onNavigateBack) {&#10;                        Icon(&#10;                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                            contentDescription = &quot;Volver&quot;&#10;                        )&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = MaterialTheme.colorScheme.primary,&#10;                    titleContentColor = MaterialTheme.colorScheme.onPrimary,&#10;                    navigationIconContentColor = MaterialTheme.colorScheme.onPrimary&#10;                )&#10;            )&#10;        }&#10;    ) { paddingValues -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues)&#10;                .background(MaterialTheme.colorScheme.background)&#10;        ) {&#10;            // Barra de progreso&#10;            LinearProgressIndicator(&#10;                progress = { progreso },&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .height(8.dp),&#10;                color = MaterialTheme.colorScheme.primary,&#10;                trackColor = MaterialTheme.colorScheme.surfaceVariant,&#10;            )&#10;&#10;            // Instrucciones&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.primaryContainer&#10;                ),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(16.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    Text(&#10;                        text = &quot;️ Valida las siguientes señas&quot;,&#10;                        fontSize = 18.sp,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = MaterialTheme.colorScheme.onPrimaryContainer,&#10;                        textAlign = TextAlign.Center&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    Text(&#10;                        text = &quot;Toca cada seña para validarla con la cámara&quot;,&#10;                        fontSize = 14.sp,&#10;                        color = MaterialTheme.colorScheme.onPrimaryContainer.copy(alpha = 0.8f),&#10;                        textAlign = TextAlign.Center&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Lista de señas&#10;            LazyColumn(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(horizontal = 16.dp),&#10;                verticalArrangement = Arrangement.spacedBy(12.dp)&#10;            ) {&#10;                items(senas) { sena -&gt;&#10;                    SenaCard(&#10;                        sena = sena,&#10;                        onClick = {&#10;                            if (!sena.completada) {&#10;                                onNavigateToValidacion(sena.letra, leccionId)&#10;                            }&#10;                        }&#10;                    )&#10;                }&#10;                &#10;                item {&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Diálogo de lección completada&#10;    if (showCompletedDialog) {&#10;        AlertDialog(&#10;            onDismissRequest = { },&#10;            title = {&#10;                Column(&#10;                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    Text(&#10;                        text = &quot;&quot;,&#10;                        fontSize = 64.sp,&#10;                        textAlign = TextAlign.Center&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    Text(&#10;                        text = &quot;¡Lección Completada!&quot;,&#10;                        fontSize = 24.sp,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = Color(0xFF4CAF50),&#10;                        textAlign = TextAlign.Center&#10;                    )&#10;                }&#10;            },&#10;            text = {&#10;                Column(&#10;                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Has completado todas las señas:&quot;,&#10;                        textAlign = TextAlign.Center,&#10;                        fontSize = 16.sp,&#10;                        fontWeight = FontWeight.Medium&#10;                    )&#10;                    Spacer(modifier = Modifier.height(12.dp))&#10;                    Text(&#10;                        text = senas.joinToString(&quot; • &quot;) { it.letra },&#10;                        textAlign = TextAlign.Center,&#10;                        fontSize = 20.sp,&#10;                        color = MaterialTheme.colorScheme.primary,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                }&#10;            },&#10;            confirmButton = {&#10;                Button(&#10;                    onClick = {&#10;                        showCompletedDialog = false&#10;                        onLeccionCompletada()&#10;                    },&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    colors = ButtonDefaults.buttonColors(&#10;                        containerColor = Color(0xFF4CAF50)&#10;                    )&#10;                ) {&#10;                    Text(&quot;Finalizar&quot;, fontSize = 16.sp)&#10;                }&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SenaCard(&#10;    sena: SenaItem,&#10;    onClick: () -&gt; Unit&#10;) {&#10;    ElevatedCard(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .clickable(enabled = !sena.completada, onClick = onClick),&#10;        colors = CardDefaults.elevatedCardColors(&#10;            containerColor = if (sena.completada) {&#10;                MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.5f)&#10;            } else {&#10;                MaterialTheme.colorScheme.surface&#10;            }&#10;        ),&#10;        elevation = CardDefaults.elevatedCardElevation(&#10;            defaultElevation = if (sena.completada) 2.dp else 6.dp&#10;        )&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(20.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Icono izquierdo&#10;            Box(&#10;                modifier = Modifier&#10;                    .size(60.dp)&#10;                    .background(&#10;                        if (sena.completada) {&#10;                            Color(0xFF4CAF50)&#10;                        } else {&#10;                            MaterialTheme.colorScheme.primaryContainer&#10;                        },&#10;                        RoundedCornerShape(30.dp)&#10;                    ),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                if (sena.completada) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Check,&#10;                        contentDescription = &quot;Completada&quot;,&#10;                        tint = Color.White,&#10;                        modifier = Modifier.size(32.dp)&#10;                    )&#10;                } else {&#10;                    Text(&#10;                        text = sena.letra,&#10;                        fontSize = 28.sp,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = MaterialTheme.colorScheme.onPrimaryContainer&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.width(16.dp))&#10;&#10;            // Información&#10;            Column(&#10;                modifier = Modifier.weight(1f)&#10;            ) {&#10;                Text(&#10;                    text = if (sena.completada) &quot;✓ ${sena.letra}&quot; else sena.letra,&#10;                    fontSize = 24.sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = if (sena.completada) {&#10;                        MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)&#10;                    } else {&#10;                        MaterialTheme.colorScheme.onSurface&#10;                    }&#10;                )&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;                Text(&#10;                    text = sena.descripcion,&#10;                    fontSize = 14.sp,&#10;                    color = MaterialTheme.colorScheme.onSurface.copy(&#10;                        alpha = if (sena.completada) 0.4f else 0.7f&#10;                    )&#10;                )&#10;                if (sena.completada) {&#10;                    Spacer(modifier = Modifier.height(4.dp))&#10;                    Text(&#10;                        text = &quot;Completada&quot;,&#10;                        fontSize = 12.sp,&#10;                        color = Color(0xFF4CAF50),&#10;                        fontWeight = FontWeight.Medium&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Icono derecho&#10;            if (!sena.completada) {&#10;                Icon(&#10;                    imageVector = Icons.Default.PlayArrow,&#10;                    contentDescription = &quot;Validar&quot;,&#10;                    tint = MaterialTheme.colorScheme.primary,&#10;                    modifier = Modifier.size(32.dp)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/ecohand/presentation/lecciones/LeccionMultiValidacionScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/ecohand/presentation/lecciones/LeccionMultiValidacionScreen.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.example.ecohand.presentation.lecciones&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Check&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.zIndex&#10;import com.example.ecohand.data.local.database.EcoHandDatabase&#10;import com.example.ecohand.data.repository.LeccionRepository&#10;import com.example.ecohand.data.session.UserSession&#10;import com.example.ecohand.presentation.senas.VowelValidationScreen&#10;import kotlinx.coroutines.launch&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun LeccionMultiValidacionScreen(&#10;    leccionId: Int,&#10;    senasAValidar: List&lt;String&gt;,&#10;    onNavigateBack: () -&gt; Unit,&#10;    onLeccionCompletada: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    var indiceActual by remember { mutableStateOf(0) }&#10;    var showProgressDialog by remember { mutableStateOf(false) }&#10;    var showCompletedDialog by remember { mutableStateOf(false) }&#10;&#10;    val scope = rememberCoroutineScope()&#10;    val database = remember { EcoHandDatabase.getDatabase(context) }&#10;    val leccionRepository = remember {&#10;        LeccionRepository(&#10;            database.leccionDao(),&#10;            database.progresoLeccionDao(),&#10;            database.estadisticasUsuarioDao()&#10;        )&#10;    }&#10;    val userSession = remember { UserSession.getInstance(context) }&#10;&#10;    // Calcular progreso&#10;    val progreso = ((indiceActual + 1).toFloat() / senasAValidar.size.toFloat())&#10;    val senasTotal = senasAValidar.size&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = {&#10;                    Column {&#10;                        Text(&#10;                            text = &quot;Práctica de Lección&quot;,&#10;                            fontWeight = FontWeight.Bold,&#10;                            fontSize = 18.sp&#10;                        )&#10;                        Text(&#10;                            text = &quot;Seña ${indiceActual + 1} de $senasTotal: ${senasAValidar[indiceActual]}&quot;,&#10;                            fontSize = 12.sp,&#10;                            color = MaterialTheme.colorScheme.onPrimary.copy(alpha = 0.8f)&#10;                        )&#10;                    }&#10;                },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onNavigateBack) {&#10;                        Icon(&#10;                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                            contentDescription = &quot;Volver&quot;&#10;                        )&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = MaterialTheme.colorScheme.primary,&#10;                    titleContentColor = MaterialTheme.colorScheme.onPrimary,&#10;                    navigationIconContentColor = MaterialTheme.colorScheme.onPrimary&#10;                )&#10;            )&#10;        }&#10;    ) { paddingValues -&gt;&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues)&#10;        ) {&#10;            // Pantalla de validación actual (ocupa toda la pantalla)&#10;            if (indiceActual &lt; senasAValidar.size) {&#10;                VowelValidationScreen(&#10;                    vowel = senasAValidar[indiceActual],&#10;                    leccionId = 0,&#10;                    onNavigateBack = onNavigateBack,&#10;                    onLeccionCompletada = {&#10;                        // Avanzar a la siguiente seña&#10;                        if (indiceActual &lt; senasAValidar.size - 1) {&#10;                            showProgressDialog = true&#10;                        } else {&#10;                            // Última seña completada&#10;                            scope.launch {&#10;                                try {&#10;                                    val usuarioId = userSession.getUserId()&#10;                                    leccionRepository.completarLeccion(usuarioId, leccionId)&#10;                                    showCompletedDialog = true&#10;                                } catch (e: Exception) {&#10;                                    showCompletedDialog = true&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;&#10;            // Barra de progreso e indicadores en la parte INFERIOR (encima de la validación)&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .align(Alignment.BottomCenter)&#10;                    .background(MaterialTheme.colorScheme.surface.copy(alpha = 0.95f))&#10;                    .padding(16.dp)&#10;                    .zIndex(10f),&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                // Indicadores de señas&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.Center,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    senasAValidar.forEachIndexed { index, sena -&gt;&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .size(50.dp)&#10;                                .background(&#10;                                    when {&#10;                                        index &lt; indiceActual -&gt; Color(0xFF4CAF50) // Completada&#10;                                        index == indiceActual -&gt; MaterialTheme.colorScheme.primary // Actual&#10;                                        else -&gt; MaterialTheme.colorScheme.surfaceVariant // Pendiente&#10;                                    },&#10;                                    RoundedCornerShape(25.dp)&#10;                                ),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            if (index &lt; indiceActual) {&#10;                                Icon(&#10;                                    imageVector = Icons.Default.Check,&#10;                                    contentDescription = &quot;Completada&quot;,&#10;                                    tint = Color.White,&#10;                                    modifier = Modifier.size(28.dp)&#10;                                )&#10;                            } else {&#10;                                Text(&#10;                                    text = sena,&#10;                                    color = if (index &lt;= indiceActual) Color.White&#10;                                           else MaterialTheme.colorScheme.onSurfaceVariant,&#10;                                    fontWeight = FontWeight.Bold,&#10;                                    fontSize = 18.sp&#10;                                )&#10;                            }&#10;                        }&#10;&#10;                        // Separador entre señas&#10;                        if (index &lt; senasAValidar.size - 1) {&#10;                            Spacer(modifier = Modifier.width(12.dp))&#10;                        }&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(12.dp))&#10;&#10;                // Barra de progreso&#10;                LinearProgressIndicator(&#10;                    progress = { progreso },&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .height(8.dp),&#10;                    color = MaterialTheme.colorScheme.primary,&#10;                    trackColor = MaterialTheme.colorScheme.surfaceVariant,&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                // Texto de progreso&#10;                Text(&#10;                    text = &quot;${indiceActual + 1} de $senasTotal completadas&quot;,&#10;                    fontSize = 14.sp,&#10;                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f),&#10;                    fontWeight = FontWeight.Medium&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    // Diálogo único para progreso (siguiente seña) y completado&#10;    if (showProgressDialog) {&#10;        AlertDialog(&#10;            onDismissRequest = { },&#10;            title = {&#10;                Column(&#10;                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Check,&#10;                        contentDescription = &quot;Éxito&quot;,&#10;                        tint = Color(0xFF4CAF50),&#10;                        modifier = Modifier.size(48.dp)&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    Text(&#10;                        text = &quot;¡Seña Correcta!&quot;,&#10;                        fontSize = 24.sp,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = Color(0xFF4CAF50),&#10;                        textAlign = TextAlign.Center&#10;                    )&#10;                }&#10;            },&#10;            text = {&#10;                Column(&#10;                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    Text(&#10;                        text = &quot;✅ ${senasAValidar[indiceActual]}&quot;,&#10;                        fontSize = 32.sp,&#10;                        textAlign = TextAlign.Center&#10;                    )&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                    Text(&#10;                        text = &quot;Ahora valida la siguiente seña:&quot;,&#10;                        textAlign = TextAlign.Center,&#10;                        fontSize = 16.sp,&#10;                        color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    Text(&#10;                        text = senasAValidar[indiceActual + 1],&#10;                        textAlign = TextAlign.Center,&#10;                        fontSize = 28.sp,&#10;                        color = MaterialTheme.colorScheme.primary,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                }&#10;            },&#10;            confirmButton = {&#10;                Button(&#10;                    onClick = {&#10;                        indiceActual++&#10;                        showProgressDialog = false&#10;                    },&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    colors = ButtonDefaults.buttonColors(&#10;                        containerColor = Color(0xFF4CAF50)&#10;                    )&#10;                ) {&#10;                    Text(&quot;Continuar&quot;, fontSize = 16.sp)&#10;                }&#10;            }&#10;        )&#10;    }&#10;&#10;    // Diálogo de lección completada&#10;    if (showCompletedDialog) {&#10;        AlertDialog(&#10;            onDismissRequest = { },&#10;            title = {&#10;                Column(&#10;                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    Text(&#10;                        text = &quot;&quot;,&#10;                        fontSize = 64.sp,&#10;                        textAlign = TextAlign.Center&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    Text(&#10;                        text = &quot;¡Lección Completada!&quot;,&#10;                        fontSize = 24.sp,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = Color(0xFF4CAF50),&#10;                        textAlign = TextAlign.Center&#10;                    )&#10;                }&#10;            },&#10;            text = {&#10;                Column(&#10;                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Has completado todas las señas:&quot;,&#10;                        textAlign = TextAlign.Center,&#10;                        fontSize = 16.sp,&#10;                        fontWeight = FontWeight.Medium&#10;                    )&#10;                    Spacer(modifier = Modifier.height(12.dp))&#10;                    Text(&#10;                        text = senasAValidar.joinToString(&quot; → &quot;),&#10;                        textAlign = TextAlign.Center,&#10;                        fontSize = 20.sp,&#10;                        color = MaterialTheme.colorScheme.primary,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                }&#10;            },&#10;            confirmButton = {&#10;                Button(&#10;                    onClick = {&#10;                        showCompletedDialog = false&#10;                        onLeccionCompletada()&#10;                    },&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    colors = ButtonDefaults.buttonColors(&#10;                        containerColor = Color(0xFF4CAF50)&#10;                    )&#10;                ) {&#10;                    Text(&quot;Finalizar&quot;, fontSize = 16.sp)&#10;                }&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/ecohand/presentation/main/MainScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/ecohand/presentation/main/MainScreen.kt" />
              <option name="originalContent" value="package com.example.ecohand.presentation.main&#10;&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.NavigationBar&#10;import androidx.compose.material3.NavigationBarItem&#10;import androidx.compose.material3.NavigationBarItemDefaults&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.navigation.NavHostController&#10;import androidx.navigation.NavType&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.compose.currentBackStackEntryAsState&#10;import androidx.navigation.compose.rememberNavController&#10;import androidx.navigation.navArgument&#10;import com.example.ecohand.data.local.database.EcoHandDatabase&#10;import com.example.ecohand.data.repository.DiccionarioRepository&#10;import com.example.ecohand.data.repository.JuegoRepository&#10;import com.example.ecohand.data.repository.PerfilRepository&#10;import com.example.ecohand.data.repository.ProgresoRepository&#10;import com.example.ecohand.data.session.UserSession&#10;import com.example.ecohand.navigation.Screen&#10;import com.example.ecohand.navigation.bottomNavItems&#10;import com.example.ecohand.presentation.diccionario.DiccionarioViewModel&#10;import com.example.ecohand.presentation.home.InicioScreen&#10;import com.example.ecohand.presentation.juegos.JuegosScreen&#10;import com.example.ecohand.presentation.juegos.JuegosViewModel&#10;import com.example.ecohand.presentation.lecciones.LeccionesScreen&#10;import com.example.ecohand.presentation.lecciones.LeccionDetalleScreen&#10;import com.example.ecohand.presentation.lecciones.LeccionPracticaScreen&#10;import com.example.ecohand.presentation.perfil.*&#10;import com.example.ecohand.presentation.progreso.ProgresoScreen&#10;import com.example.ecohand.presentation.progreso.ProgresoViewModel&#10;&#10;@Composable&#10;fun MainScreen(&#10;    onLogout: () -&gt; Unit = {}&#10;) {&#10;    val navController = rememberNavController()&#10;    val context = LocalContext.current&#10;&#10;    // Inicializar base de datos y repositorios&#10;    val database = EcoHandDatabase.getDatabase(context)&#10;    val userSession = UserSession.getInstance(context)&#10;    val usuarioId = userSession.getUserId()&#10;&#10;    // Crear ProgresoRepository&#10;    val progresoRepository = ProgresoRepository(&#10;        estadisticasUsuarioDao = database.estadisticasUsuarioDao(),&#10;        progresoLeccionDao = database.progresoLeccionDao(),&#10;        actividadDiariaDao = database.actividadDiariaDao(),&#10;        logroDao = database.logroDao(),&#10;        logroUsuarioDao = database.logroUsuarioDao(),&#10;        leccionDao = database.leccionDao()&#10;    )&#10;&#10;    // Crear ProgresoViewModel con remember para evitar recreaciones&#10;    val progresoViewModel = remember(usuarioId) {&#10;        ProgresoViewModel(progresoRepository, usuarioId)&#10;    }&#10;&#10;    // Crear JuegoRepository&#10;    val juegoRepository = JuegoRepository(&#10;        senaDao = database.senaDao(),&#10;        partidaJuegoDao = database.partidaJuegoDao(),&#10;        estadisticasUsuarioDao = database.estadisticasUsuarioDao()&#10;    )&#10;&#10;    // Crear JuegosViewModel con remember para evitar recreaciones&#10;    val juegosViewModel = remember(usuarioId) {&#10;        JuegosViewModel(juegoRepository, usuarioId)&#10;    }&#10;&#10;    // Crear PerfilRepository&#10;    val perfilRepository = PerfilRepository(&#10;        userDao = database.userDao(),&#10;        estadisticasUsuarioDao = database.estadisticasUsuarioDao(),&#10;        progresoLeccionDao = database.progresoLeccionDao()&#10;    )&#10;&#10;    // Crear PerfilViewModel con remember para evitar recreaciones&#10;    val perfilViewModel = remember(usuarioId) {&#10;        PerfilViewModel(perfilRepository, usuarioId)&#10;    }&#10;&#10;    // Crear DiccionarioRepository&#10;    val diccionarioRepository = DiccionarioRepository(&#10;        senaDao = database.senaDao()&#10;    )&#10;&#10;    // Crear DiccionarioViewModel con remember para evitar recreaciones&#10;    val diccionarioViewModel = remember {&#10;        DiccionarioViewModel(diccionarioRepository)&#10;    }&#10;&#10;    Scaffold(&#10;        bottomBar = {&#10;            val currentRoute = navController.currentBackStackEntryAsState().value?.destination?.route&#10;            // Ocultar bottom bar en pantallas de detalle, práctica y detección&#10;            if (currentRoute != null &amp;&amp;&#10;                !currentRoute.startsWith(&quot;leccion_detalle&quot;) &amp;&amp;&#10;                !currentRoute.startsWith(&quot;leccion_practica&quot;) &amp;&amp;&#10;                currentRoute != Screen.DetectionTest.route) {&#10;                BottomNavigationBar(navController = navController)&#10;            }&#10;        }&#10;    ) { innerPadding -&gt;&#10;        MainNavHost(&#10;            navController = navController,&#10;            progresoViewModel = progresoViewModel,&#10;            juegosViewModel = juegosViewModel,&#10;            perfilViewModel = perfilViewModel,&#10;            diccionarioViewModel = diccionarioViewModel,&#10;            onLogout = onLogout,&#10;            modifier = Modifier.padding(innerPadding)&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun BottomNavigationBar(navController: NavHostController) {&#10;    val navBackStackEntry by navController.currentBackStackEntryAsState()&#10;    val currentRoute = navBackStackEntry?.destination?.route&#10;&#10;    NavigationBar(&#10;        containerColor = MaterialTheme.colorScheme.primary,&#10;        contentColor = MaterialTheme.colorScheme.onPrimary&#10;    ) {&#10;        bottomNavItems.forEach { item -&gt;&#10;            val isSelected = currentRoute == item.route&#10;            NavigationBarItem(&#10;                icon = {&#10;                    Icon(&#10;                        imageVector = if (isSelected) item.selectedIcon else item.icon,&#10;                        contentDescription = item.title&#10;                    )&#10;                },&#10;                label = { Text(text = item.title) },&#10;                selected = isSelected,&#10;                onClick = {&#10;                    navController.navigate(item.route) {&#10;                        navController.graph.startDestinationRoute?.let { route -&gt;&#10;                            popUpTo(route) {&#10;                                saveState = true&#10;                            }&#10;                        }&#10;                        launchSingleTop = true&#10;                        restoreState = true&#10;                    }&#10;                },&#10;                colors = NavigationBarItemDefaults.colors(&#10;                    selectedIconColor = MaterialTheme.colorScheme.onPrimary,&#10;                    selectedTextColor = MaterialTheme.colorScheme.onPrimary,&#10;                    unselectedIconColor = MaterialTheme.colorScheme.onPrimary.copy(alpha = 0.6f),&#10;                    unselectedTextColor = MaterialTheme.colorScheme.onPrimary.copy(alpha = 0.6f),&#10;                    indicatorColor = MaterialTheme.colorScheme.secondary&#10;                )&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun MainNavHost(&#10;    navController: NavHostController,&#10;    progresoViewModel: ProgresoViewModel,&#10;    juegosViewModel: JuegosViewModel,&#10;    perfilViewModel: PerfilViewModel,&#10;    diccionarioViewModel: DiccionarioViewModel,&#10;    onLogout: () -&gt; Unit = {},&#10;    modifier: Modifier = Modifier&#10;) {&#10;    NavHost(&#10;        navController = navController,&#10;        startDestination = Screen.Inicio.route,&#10;        modifier = modifier&#10;    ) {&#10;        composable(Screen.Inicio.route) {&#10;            InicioScreen(&#10;                onNavigateToLeccion = { leccionId -&gt;&#10;                    navController.navigate(Screen.LeccionDetalle.createRoute(leccionId))&#10;                }&#10;            )&#10;        }&#10;        composable(Screen.Lecciones.route) {&#10;            LeccionesScreen(&#10;                onNavigateToDetalle = { leccionId -&gt;&#10;                    navController.navigate(Screen.LeccionDetalle.createRoute(leccionId))&#10;                }&#10;            )&#10;        }&#10;        composable(&#10;            route = Screen.LeccionDetalle.route,&#10;            arguments = listOf(navArgument(&quot;leccionId&quot;) { type = NavType.IntType })&#10;        ) { backStackEntry -&gt;&#10;            val leccionId = backStackEntry.arguments?.getInt(&quot;leccionId&quot;) ?: return@composable&#10;            LeccionDetalleScreen(&#10;                leccionId = leccionId,&#10;                onNavigateBack = { navController.popBackStack() },&#10;                onNavigateToPractica = { id -&gt;&#10;                    // Si es la lección de &quot;Saludos Básicos&quot; (ID 1), ir a validación de &quot;Hola&quot;&#10;                    if (id == 1) {&#10;                        navController.navigate(Screen.VowelValidation.createRoute(&quot;Hola&quot;, leccionId = 1))&#10;                    } else {&#10;                        navController.navigate(Screen.LeccionPractica.createRoute(id))&#10;                    }&#10;                }&#10;            )&#10;        }&#10;        composable(&#10;            route = Screen.LeccionPractica.route,&#10;            arguments = listOf(navArgument(&quot;leccionId&quot;) { type = NavType.IntType })&#10;        ) { backStackEntry -&gt;&#10;            val leccionId = backStackEntry.arguments?.getInt(&quot;leccionId&quot;) ?: return@composable&#10;            LeccionPracticaScreen(&#10;                leccionId = leccionId,&#10;                onNavigateBack = { navController.popBackStack() },&#10;                onLeccionCompletada = {&#10;                    // Volver a la lista de lecciones&#10;                    navController.popBackStack(Screen.Lecciones.route, inclusive = false)&#10;                }&#10;            )&#10;        }&#10;        composable(Screen.Progreso.route) {&#10;            ProgresoScreen(viewModel = progresoViewModel)&#10;        }&#10;        composable(Screen.Juegos.route) {&#10;            JuegosScreen(viewModel = juegosViewModel)&#10;        }&#10;        composable(Screen.Perfil.route) {&#10;            PerfilScreen(&#10;                viewModel = perfilViewModel,&#10;                onNavigateToConfiguracion = {&#10;                    navController.navigate(Screen.Configuracion.route)&#10;                },&#10;                onNavigateToMisLogros = {&#10;                    navController.navigate(Screen.MisLogros.route)&#10;                },&#10;                onNavigateToDiccionario = {&#10;                    navController.navigate(Screen.DiccionarioLSP.route)&#10;                },&#10;                onNavigateToCompartir = {&#10;                    navController.navigate(Screen.CompartirApp.route)&#10;                },&#10;                onNavigateToAyuda = {&#10;                    navController.navigate(Screen.AyudaSoporte.route)&#10;                },&#10;                onNavigateToDetectionTest = {&#10;                    navController.navigate(Screen.CategorySelection.route)&#10;                }&#10;            )&#10;        }&#10;&#10;        // Pantallas de perfil&#10;        composable(Screen.Configuracion.route) {&#10;            ConfiguracionScreen(&#10;                onNavigateBack = { navController.popBackStack() },&#10;                onLogout = onLogout&#10;            )&#10;        }&#10;        composable(Screen.MisLogros.route) {&#10;            MisLogrosScreen(&#10;                onNavigateBack = { navController.popBackStack() }&#10;            )&#10;        }&#10;        composable(Screen.DiccionarioLSP.route) {&#10;            DiccionarioLSPScreen(&#10;                viewModel = diccionarioViewModel,&#10;                onNavigateBack = { navController.popBackStack() }&#10;            )&#10;        }&#10;        composable(Screen.CompartirApp.route) {&#10;            CompartirAppScreen(&#10;                onNavigateBack = { navController.popBackStack() }&#10;            )&#10;        }&#10;        composable(Screen.AyudaSoporte.route) {&#10;            AyudaSoporteScreen(&#10;                onNavigateBack = { navController.popBackStack() }&#10;            )&#10;        }&#10;&#10;        // Pantalla de prueba de detección&#10;        composable(Screen.DetectionTest.route) {&#10;            com.example.ecohand.presentation.components.DetectionTestScreen(&#10;                onNavigateBack = { navController.popBackStack() }&#10;            )&#10;        }&#10;&#10;        // Pantallas de validación de señas&#10;        composable(Screen.CategorySelection.route) {&#10;            com.example.ecohand.presentation.senas.CategorySelectionScreen(&#10;                onNavigateBack = { navController.popBackStack() },&#10;                onCategorySelected = { category -&gt;&#10;                    navController.navigate(Screen.VowelSelection.createRoute(category))&#10;                }&#10;            )&#10;        }&#10;&#10;        composable(&#10;            route = Screen.VowelSelection.route,&#10;            arguments = listOf(&#10;                navArgument(&quot;category&quot;) { type = NavType.StringType }&#10;            )&#10;        ) { backStackEntry -&gt;&#10;            val category = backStackEntry.arguments?.getString(&quot;category&quot;) ?: &quot;Alfabeto&quot;&#10;            com.example.ecohand.presentation.senas.VowelSelectionScreen(&#10;                category = category,&#10;                onNavigateBack = { navController.popBackStack() },&#10;                onVowelSelected = { vowel -&gt;&#10;                    navController.navigate(Screen.VowelValidation.createRoute(vowel))&#10;                }&#10;            )&#10;        }&#10;&#10;        composable(&#10;            route = Screen.VowelValidation.route,&#10;            arguments = listOf(&#10;                navArgument(&quot;vowel&quot;) { type = NavType.StringType },&#10;                navArgument(&quot;leccionId&quot;) {&#10;                    type = NavType.IntType&#10;                    defaultValue = -1&#10;                }&#10;            )&#10;        ) { backStackEntry -&gt;&#10;            val vowel = backStackEntry.arguments?.getString(&quot;vowel&quot;) ?: &quot;A&quot;&#10;            val leccionIdArg = backStackEntry.arguments?.getInt(&quot;leccionId&quot;) ?: -1&#10;            val leccionId = if (leccionIdArg &gt; 0) leccionIdArg else null&#10;            com.example.ecohand.presentation.senas.VowelValidationScreen(&#10;                vowel = vowel,&#10;                leccionId = leccionId,&#10;                onNavigateBack = { navController.popBackStack() },&#10;                onLeccionCompletada = {&#10;                    // Volver a la lista de lecciones&#10;                    navController.popBackStack(Screen.Lecciones.route, inclusive = false)&#10;                }&#10;            )&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.ecohand.presentation.main&#10;&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.NavigationBar&#10;import androidx.compose.material3.NavigationBarItem&#10;import androidx.compose.material3.NavigationBarItemDefaults&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.navigation.NavHostController&#10;import androidx.navigation.NavType&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.compose.currentBackStackEntryAsState&#10;import androidx.navigation.compose.rememberNavController&#10;import androidx.navigation.navArgument&#10;import com.example.ecohand.data.local.database.EcoHandDatabase&#10;import com.example.ecohand.data.repository.DiccionarioRepository&#10;import com.example.ecohand.data.repository.JuegoRepository&#10;import com.example.ecohand.data.repository.PerfilRepository&#10;import com.example.ecohand.data.repository.ProgresoRepository&#10;import com.example.ecohand.data.session.UserSession&#10;import com.example.ecohand.navigation.Screen&#10;import com.example.ecohand.navigation.bottomNavItems&#10;import com.example.ecohand.presentation.diccionario.DiccionarioViewModel&#10;import com.example.ecohand.presentation.home.InicioScreen&#10;import com.example.ecohand.presentation.juegos.JuegosScreen&#10;import com.example.ecohand.presentation.juegos.JuegosViewModel&#10;import com.example.ecohand.presentation.lecciones.LeccionesScreen&#10;import com.example.ecohand.presentation.lecciones.LeccionDetalleScreen&#10;import com.example.ecohand.presentation.lecciones.LeccionPracticaScreen&#10;import com.example.ecohand.presentation.perfil.*&#10;import com.example.ecohand.presentation.progreso.ProgresoScreen&#10;import com.example.ecohand.presentation.progreso.ProgresoViewModel&#10;&#10;@Composable&#10;fun MainScreen(&#10;    onLogout: () -&gt; Unit = {}&#10;) {&#10;    val navController = rememberNavController()&#10;    val context = LocalContext.current&#10;&#10;    // Inicializar base de datos y repositorios&#10;    val database = EcoHandDatabase.getDatabase(context)&#10;    val userSession = UserSession.getInstance(context)&#10;    val usuarioId = userSession.getUserId()&#10;&#10;    // Crear ProgresoRepository&#10;    val progresoRepository = ProgresoRepository(&#10;        estadisticasUsuarioDao = database.estadisticasUsuarioDao(),&#10;        progresoLeccionDao = database.progresoLeccionDao(),&#10;        actividadDiariaDao = database.actividadDiariaDao(),&#10;        logroDao = database.logroDao(),&#10;        logroUsuarioDao = database.logroUsuarioDao(),&#10;        leccionDao = database.leccionDao()&#10;    )&#10;&#10;    // Crear ProgresoViewModel con remember para evitar recreaciones&#10;    val progresoViewModel = remember(usuarioId) {&#10;        ProgresoViewModel(progresoRepository, usuarioId)&#10;    }&#10;&#10;    // Crear JuegoRepository&#10;    val juegoRepository = JuegoRepository(&#10;        senaDao = database.senaDao(),&#10;        partidaJuegoDao = database.partidaJuegoDao(),&#10;        estadisticasUsuarioDao = database.estadisticasUsuarioDao()&#10;    )&#10;&#10;    // Crear JuegosViewModel con remember para evitar recreaciones&#10;    val juegosViewModel = remember(usuarioId) {&#10;        JuegosViewModel(juegoRepository, usuarioId)&#10;    }&#10;&#10;    // Crear PerfilRepository&#10;    val perfilRepository = PerfilRepository(&#10;        userDao = database.userDao(),&#10;        estadisticasUsuarioDao = database.estadisticasUsuarioDao(),&#10;        progresoLeccionDao = database.progresoLeccionDao()&#10;    )&#10;&#10;    // Crear PerfilViewModel con remember para evitar recreaciones&#10;    val perfilViewModel = remember(usuarioId) {&#10;        PerfilViewModel(perfilRepository, usuarioId)&#10;    }&#10;&#10;    // Crear DiccionarioRepository&#10;    val diccionarioRepository = DiccionarioRepository(&#10;        senaDao = database.senaDao()&#10;    )&#10;&#10;    // Crear DiccionarioViewModel con remember para evitar recreaciones&#10;    val diccionarioViewModel = remember {&#10;        DiccionarioViewModel(diccionarioRepository)&#10;    }&#10;&#10;    Scaffold(&#10;        bottomBar = {&#10;            val currentRoute = navController.currentBackStackEntryAsState().value?.destination?.route&#10;            // Ocultar bottom bar en pantallas de detalle, práctica y detección&#10;            if (currentRoute != null &amp;&amp;&#10;                !currentRoute.startsWith(&quot;leccion_detalle&quot;) &amp;&amp;&#10;                !currentRoute.startsWith(&quot;leccion_practica&quot;) &amp;&amp;&#10;                currentRoute != Screen.DetectionTest.route) {&#10;                BottomNavigationBar(navController = navController)&#10;            }&#10;        }&#10;    ) { innerPadding -&gt;&#10;        MainNavHost(&#10;            navController = navController,&#10;            progresoViewModel = progresoViewModel,&#10;            juegosViewModel = juegosViewModel,&#10;            perfilViewModel = perfilViewModel,&#10;            diccionarioViewModel = diccionarioViewModel,&#10;            onLogout = onLogout,&#10;            modifier = Modifier.padding(innerPadding)&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun BottomNavigationBar(navController: NavHostController) {&#10;    val navBackStackEntry by navController.currentBackStackEntryAsState()&#10;    val currentRoute = navBackStackEntry?.destination?.route&#10;&#10;    NavigationBar(&#10;        containerColor = MaterialTheme.colorScheme.primary,&#10;        contentColor = MaterialTheme.colorScheme.onPrimary&#10;    ) {&#10;        bottomNavItems.forEach { item -&gt;&#10;            val isSelected = currentRoute == item.route&#10;            NavigationBarItem(&#10;                icon = {&#10;                    Icon(&#10;                        imageVector = if (isSelected) item.selectedIcon else item.icon,&#10;                        contentDescription = item.title&#10;                    )&#10;                },&#10;                label = { Text(text = item.title) },&#10;                selected = isSelected,&#10;                onClick = {&#10;                    navController.navigate(item.route) {&#10;                        navController.graph.startDestinationRoute?.let { route -&gt;&#10;                            popUpTo(route) {&#10;                                saveState = true&#10;                            }&#10;                        }&#10;                        launchSingleTop = true&#10;                        restoreState = true&#10;                    }&#10;                },&#10;                colors = NavigationBarItemDefaults.colors(&#10;                    selectedIconColor = MaterialTheme.colorScheme.onPrimary,&#10;                    selectedTextColor = MaterialTheme.colorScheme.onPrimary,&#10;                    unselectedIconColor = MaterialTheme.colorScheme.onPrimary.copy(alpha = 0.6f),&#10;                    unselectedTextColor = MaterialTheme.colorScheme.onPrimary.copy(alpha = 0.6f),&#10;                    indicatorColor = MaterialTheme.colorScheme.secondary&#10;                )&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun MainNavHost(&#10;    navController: NavHostController,&#10;    progresoViewModel: ProgresoViewModel,&#10;    juegosViewModel: JuegosViewModel,&#10;    perfilViewModel: PerfilViewModel,&#10;    diccionarioViewModel: DiccionarioViewModel,&#10;    onLogout: () -&gt; Unit = {},&#10;    modifier: Modifier = Modifier&#10;) {&#10;    NavHost(&#10;        navController = navController,&#10;        startDestination = Screen.Inicio.route,&#10;        modifier = modifier&#10;    ) {&#10;        composable(Screen.Inicio.route) {&#10;            InicioScreen(&#10;                onNavigateToLeccion = { leccionId -&gt;&#10;                    navController.navigate(Screen.LeccionDetalle.createRoute(leccionId))&#10;                }&#10;            )&#10;        }&#10;        composable(Screen.Lecciones.route) {&#10;            LeccionesScreen(&#10;                onNavigateToDetalle = { leccionId -&gt;&#10;                    navController.navigate(Screen.LeccionDetalle.createRoute(leccionId))&#10;                }&#10;            )&#10;        }&#10;        composable(&#10;            route = Screen.LeccionDetalle.route,&#10;            arguments = listOf(navArgument(&quot;leccionId&quot;) { type = NavType.IntType })&#10;        ) { backStackEntry -&gt;&#10;            val leccionId = backStackEntry.arguments?.getInt(&quot;leccionId&quot;) ?: return@composable&#10;            LeccionDetalleScreen(&#10;                leccionId = leccionId,&#10;                onNavigateBack = { navController.popBackStack() },&#10;                onNavigateToPractica = { id -&gt;&#10;                    when (id) {&#10;                        1 -&gt; {&#10;                            // Saludos Básicos → Validación de &quot;Hola&quot;&#10;                            navController.navigate(Screen.VowelValidation.createRoute(&quot;Hola&quot;, leccionId = 1))&#10;                        }&#10;                        2 -&gt; {&#10;                            // Alfabeto → Lista de validación A, I, Z&#10;                            navController.navigate(Screen.LeccionListaValidacion.createRoute(2))&#10;                        }&#10;                        else -&gt; {&#10;                            // Otras lecciones → Práctica normal&#10;                            navController.navigate(Screen.LeccionPractica.createRoute(id))&#10;                        }&#10;                    }&#10;                }&#10;            )&#10;        }&#10;        composable(&#10;            route = Screen.LeccionPractica.route,&#10;            arguments = listOf(navArgument(&quot;leccionId&quot;) { type = NavType.IntType })&#10;        ) { backStackEntry -&gt;&#10;            val leccionId = backStackEntry.arguments?.getInt(&quot;leccionId&quot;) ?: return@composable&#10;            LeccionPracticaScreen(&#10;                leccionId = leccionId,&#10;                onNavigateBack = { navController.popBackStack() },&#10;                onLeccionCompletada = {&#10;                    // Volver a la lista de lecciones&#10;                    navController.popBackStack(Screen.Lecciones.route, inclusive = false)&#10;                }&#10;            )&#10;        }&#10;        composable(&#10;            route = Screen.LeccionListaValidacion.route,&#10;            arguments = listOf(navArgument(&quot;leccionId&quot;) { type = NavType.IntType })&#10;        ) { backStackEntry -&gt;&#10;            val leccionId = backStackEntry.arguments?.getInt(&quot;leccionId&quot;) ?: return@composable&#10;            &#10;            // Definir las señas según la lección&#10;            val senasAValidar = when (leccionId) {&#10;                2 -&gt; listOf(&#10;                    com.example.ecohand.presentation.lecciones.SenaItem(&quot;A&quot;, &quot;Pulgar extendido hacia afuera&quot;),&#10;                    com.example.ecohand.presentation.lecciones.SenaItem(&quot;I&quot;, &quot;Solo meñique extendido&quot;),&#10;                    com.example.ecohand.presentation.lecciones.SenaItem(&quot;Z&quot;, &quot;Índice trazando una Z&quot;)&#10;                )&#10;                else -&gt; emptyList()&#10;            }&#10;            &#10;            com.example.ecohand.presentation.lecciones.LeccionListaValidacionScreen(&#10;                leccionId = leccionId,&#10;                senasAValidar = senasAValidar,&#10;                onNavigateBack = { navController.popBackStack() },&#10;                onNavigateToValidacion = { letra, lecId -&gt;&#10;                    navController.navigate(&#10;                        Screen.VowelValidation.createRoute(letra, leccionId = lecId)&#10;                    )&#10;                },&#10;                onLeccionCompletada = {&#10;                    navController.popBackStack(Screen.Lecciones.route, inclusive = false)&#10;                }&#10;            )&#10;        }&#10;        composable(Screen.Progreso.route) {&#10;            ProgresoScreen(viewModel = progresoViewModel)&#10;        }&#10;        composable(Screen.Juegos.route) {&#10;            JuegosScreen(viewModel = juegosViewModel)&#10;        }&#10;        composable(Screen.Perfil.route) {&#10;            PerfilScreen(&#10;                viewModel = perfilViewModel,&#10;                onNavigateToConfiguracion = {&#10;                    navController.navigate(Screen.Configuracion.route)&#10;                },&#10;                onNavigateToMisLogros = {&#10;                    navController.navigate(Screen.MisLogros.route)&#10;                },&#10;                onNavigateToDiccionario = {&#10;                    navController.navigate(Screen.DiccionarioLSP.route)&#10;                },&#10;                onNavigateToCompartir = {&#10;                    navController.navigate(Screen.CompartirApp.route)&#10;                },&#10;                onNavigateToAyuda = {&#10;                    navController.navigate(Screen.AyudaSoporte.route)&#10;                },&#10;                onNavigateToDetectionTest = {&#10;                    navController.navigate(Screen.CategorySelection.route)&#10;                }&#10;            )&#10;        }&#10;&#10;        // Pantallas de perfil&#10;        composable(Screen.Configuracion.route) {&#10;            ConfiguracionScreen(&#10;                onNavigateBack = { navController.popBackStack() },&#10;                onLogout = onLogout&#10;            )&#10;        }&#10;        composable(Screen.MisLogros.route) {&#10;            MisLogrosScreen(&#10;                onNavigateBack = { navController.popBackStack() }&#10;            )&#10;        }&#10;        composable(Screen.DiccionarioLSP.route) {&#10;            DiccionarioLSPScreen(&#10;                viewModel = diccionarioViewModel,&#10;                onNavigateBack = { navController.popBackStack() }&#10;            )&#10;        }&#10;        composable(Screen.CompartirApp.route) {&#10;            CompartirAppScreen(&#10;                onNavigateBack = { navController.popBackStack() }&#10;            )&#10;        }&#10;        composable(Screen.AyudaSoporte.route) {&#10;            AyudaSoporteScreen(&#10;                onNavigateBack = { navController.popBackStack() }&#10;            )&#10;        }&#10;&#10;        // Pantalla de prueba de detección&#10;        composable(Screen.DetectionTest.route) {&#10;            com.example.ecohand.presentation.components.DetectionTestScreen(&#10;                onNavigateBack = { navController.popBackStack() }&#10;            )&#10;        }&#10;&#10;        // Pantallas de validación de señas&#10;        composable(Screen.CategorySelection.route) {&#10;            com.example.ecohand.presentation.senas.CategorySelectionScreen(&#10;                onNavigateBack = { navController.popBackStack() },&#10;                onCategorySelected = { category -&gt;&#10;                    navController.navigate(Screen.VowelSelection.createRoute(category))&#10;                }&#10;            )&#10;        }&#10;&#10;        composable(&#10;            route = Screen.VowelSelection.route,&#10;            arguments = listOf(&#10;                navArgument(&quot;category&quot;) { type = NavType.StringType }&#10;            )&#10;        ) { backStackEntry -&gt;&#10;            val category = backStackEntry.arguments?.getString(&quot;category&quot;) ?: &quot;Alfabeto&quot;&#10;            com.example.ecohand.presentation.senas.VowelSelectionScreen(&#10;                category = category,&#10;                onNavigateBack = { navController.popBackStack() },&#10;                onVowelSelected = { vowel -&gt;&#10;                    navController.navigate(Screen.VowelValidation.createRoute(vowel))&#10;                }&#10;            )&#10;        }&#10;&#10;        composable(&#10;            route = Screen.VowelValidation.route,&#10;            arguments = listOf(&#10;                navArgument(&quot;vowel&quot;) { type = NavType.StringType },&#10;                navArgument(&quot;leccionId&quot;) {&#10;                    type = NavType.IntType&#10;                    defaultValue = -1&#10;                }&#10;            )&#10;        ) { backStackEntry -&gt;&#10;            val vowel = backStackEntry.arguments?.getString(&quot;vowel&quot;) ?: &quot;A&quot;&#10;            val leccionIdArg = backStackEntry.arguments?.getInt(&quot;leccionId&quot;) ?: -1&#10;            val leccionId = if (leccionIdArg &gt; 0) leccionIdArg else null&#10;            com.example.ecohand.presentation.senas.VowelValidationScreen(&#10;                vowel = vowel,&#10;                leccionId = leccionId,&#10;                onNavigateBack = { navController.popBackStack() },&#10;                onLeccionCompletada = {&#10;                    // Volver a la lista de lecciones&#10;                    navController.popBackStack(Screen.Lecciones.route, inclusive = false)&#10;                }&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/ecohand/presentation/senas/VowelValidationScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/ecohand/presentation/senas/VowelValidationScreen.kt" />
              <option name="originalContent" value="package com.example.ecohand.presentation.senas&#10;&#10;import android.Manifest&#10;import android.content.pm.PackageManager&#10;import android.graphics.Bitmap&#10;import android.graphics.Matrix&#10;import android.util.Log&#10;import android.view.ViewGroup&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.camera.core.CameraSelector&#10;import androidx.camera.core.ImageAnalysis&#10;import androidx.camera.core.ImageProxy&#10;import androidx.camera.core.Preview&#10;import androidx.camera.lifecycle.ProcessCameraProvider&#10;import androidx.camera.view.PreviewView&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Check&#10;import androidx.compose.material.icons.filled.Refresh&#10;import androidx.compose.material.icons.filled.Info&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalLifecycleOwner&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;import androidx.core.content.ContextCompat&#10;import com.example.ecohand.ml.FaceDetector&#10;import com.example.ecohand.ml.HandDetector&#10;import com.example.ecohand.ml.VowelSignValidator&#10;import com.example.ecohand.presentation.components.DetectionOverlay&#10;import com.google.mediapipe.tasks.vision.core.RunningMode&#10;import com.google.mediapipe.tasks.vision.facelandmarker.FaceLandmarkerResult&#10;import com.google.mediapipe.tasks.vision.handlandmarker.HandLandmarkerResult&#10;import kotlinx.coroutines.launch&#10;import java.util.concurrent.Executors&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun VowelValidationScreen(&#10;    vowel: String,&#10;    leccionId: Int? = null,&#10;    onNavigateBack: () -&gt; Unit,&#10;    onLeccionCompletada: () -&gt; Unit = {}&#10;) {&#10;    val context = LocalContext.current&#10;&#10;    var hasCameraPermission by remember {&#10;        mutableStateOf(&#10;            ContextCompat.checkSelfPermission(&#10;                context,&#10;                Manifest.permission.CAMERA&#10;            ) == PackageManager.PERMISSION_GRANTED&#10;        )&#10;    }&#10;&#10;    val launcher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.RequestPermission(),&#10;        onResult = { granted -&gt;&#10;            hasCameraPermission = granted&#10;        }&#10;    )&#10;&#10;    var useFrontCamera by remember { mutableStateOf(true) }&#10;    var handResults by remember { mutableStateOf&lt;HandLandmarkerResult?&gt;(null) }&#10;    var faceResults by remember { mutableStateOf&lt;FaceLandmarkerResult?&gt;(null) }&#10;    var imageWidth by remember { mutableStateOf(640) }&#10;    var imageHeight by remember { mutableStateOf(480) }&#10;    var detectionStatus by remember { mutableStateOf(&quot;Inicializando...&quot;) }&#10;    var validationResult by remember { mutableStateOf&lt;ValidationState&gt;(ValidationState.Detecting) }&#10;    var showSuccessDialog by remember { mutableStateOf(false) }&#10;    var showInfoDialog by remember { mutableStateOf(false) }&#10;&#10;    // Detectores y validador&#10;    val handDetector = remember {&#10;        HandDetector(&#10;            context = context,&#10;            runningMode = RunningMode.LIVE_STREAM,&#10;            maxNumHands = 2 // Detectar hasta 2 manos (necesario para señas como &quot;Amigo&quot;)&#10;        )&#10;    }&#10;&#10;    val faceDetector = remember {&#10;        FaceDetector(&#10;            context = context,&#10;            runningMode = RunningMode.LIVE_STREAM,&#10;            maxNumFaces = 1&#10;        )&#10;    }&#10;&#10;    val vowelValidator = remember { VowelSignValidator() }&#10;&#10;    // Scope para completar la lección&#10;    val scope = rememberCoroutineScope()&#10;    val database = remember { com.example.ecohand.data.local.database.EcoHandDatabase.getDatabase(context) }&#10;    val leccionRepository = remember {&#10;        com.example.ecohand.data.repository.LeccionRepository(&#10;            database.leccionDao(),&#10;            database.progresoLeccionDao(),&#10;            database.estadisticasUsuarioDao()&#10;        )&#10;    }&#10;    val userSession = remember { com.example.ecohand.data.session.UserSession.getInstance(context) }&#10;&#10;    // Inicializar detectores&#10;    LaunchedEffect(Unit) {&#10;        if (!hasCameraPermission) {&#10;            launcher.launch(Manifest.permission.CAMERA)&#10;        }&#10;&#10;        val handInit = handDetector.initialize { result, _ -&gt;&#10;            handResults = result&#10;            // Validar la seña automáticamente&#10;            validationResult = validateVowelSign(result, vowel, vowelValidator)&#10;        }&#10;&#10;        val faceInit = faceDetector.initialize { result, _ -&gt;&#10;            faceResults = result&#10;        }&#10;&#10;        detectionStatus = when {&#10;            handInit &amp;&amp; faceInit -&gt; &quot;✓ Detectores listos&quot;&#10;            handInit -&gt; &quot;⚠ Solo manos listo&quot;&#10;            faceInit -&gt; &quot;⚠ Solo rostro listo&quot;&#10;            else -&gt; &quot;✗ Error al inicializar&quot;&#10;        }&#10;    }&#10;&#10;    // Mostrar diálogo de éxito cuando se valide correctamente&#10;    LaunchedEffect(validationResult) {&#10;        if (validationResult is ValidationState.Success) {&#10;            showSuccessDialog = true&#10;        }&#10;    }&#10;&#10;    // Limpiar recursos&#10;    DisposableEffect(Unit) {&#10;        onDispose {&#10;            handDetector.close()&#10;            faceDetector.close()&#10;            // Limpiar trayectorias de letras con movimiento&#10;            vowelValidator.resetZTrajectory()&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = {&#10;                    Text(&#10;                        text = &quot;Validar: $vowel&quot;,&#10;                        fontWeight = FontWeight.Bold,&#10;                        fontSize = 18.sp&#10;                    )&#10;                },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onNavigateBack) {&#10;                        Icon(&#10;                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                            contentDescription = &quot;Volver&quot;&#10;                        )&#10;                    }&#10;                },&#10;                actions = {&#10;                    // Botón de información&#10;                    IconButton(onClick = { showInfoDialog = true }) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Info,&#10;                            contentDescription = &quot;Ver información&quot;&#10;                        )&#10;                    }&#10;                    // Botón para cambiar cámara&#10;                    IconButton(onClick = { useFrontCamera = !useFrontCamera }) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Refresh,&#10;                            contentDescription = &quot;Cambiar cámara&quot;&#10;                        )&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = MaterialTheme.colorScheme.primary,&#10;                    titleContentColor = MaterialTheme.colorScheme.onPrimary,&#10;                    navigationIconContentColor = MaterialTheme.colorScheme.onPrimary,&#10;                    actionIconContentColor = MaterialTheme.colorScheme.onPrimary&#10;                )&#10;            )&#10;        }&#10;    ) { paddingValues -&gt;&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues)&#10;                .background(MaterialTheme.colorScheme.background)&#10;        ) {&#10;            // Vista de cámara con overlay ocupando todo el espacio&#10;            if (hasCameraPermission) {&#10;                // Cámara con key para forzar recomposición al cambiar de cámara&#10;                key(useFrontCamera) {&#10;                    CameraPreviewWithValidation(&#10;                        useFrontCamera = useFrontCamera,&#10;                        handDetector = handDetector,&#10;                        faceDetector = faceDetector,&#10;                        onImageDimensionsChanged = { width, height -&gt;&#10;                            imageWidth = width&#10;                            imageHeight = height&#10;                        }&#10;                    )&#10;                }&#10;&#10;                // Overlay de detecciones&#10;                DetectionOverlay(&#10;                    handResults = handResults,&#10;                    faceResults = faceResults,&#10;                    imageWidth = imageWidth,&#10;                    imageHeight = imageHeight,&#10;                    modifier = Modifier.fillMaxSize()&#10;                )&#10;&#10;                // Overlay de estado en la parte superior (texto sin fondo)&#10;                Column(&#10;                    modifier = Modifier&#10;                        .align(Alignment.TopCenter)&#10;                        .fillMaxWidth()&#10;                        .padding(16.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    // Estado de validación (texto con sombra para visibilidad)&#10;                    Text(&#10;                        text = when (validationResult) {&#10;                            is ValidationState.Detecting -&gt; &quot; Detectando...&quot;&#10;                            is ValidationState.Success -&gt; &quot;✅ ¡Correcto!&quot;&#10;                            is ValidationState.Error -&gt; &quot;❌ ${(validationResult as ValidationState.Error).message}&quot;&#10;                            is ValidationState.Waiting -&gt; &quot;⏳ Esperando seña...&quot;&#10;                        },&#10;                        fontSize = 20.sp,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = when (validationResult) {&#10;                            is ValidationState.Success -&gt; Color(0xFF4CAF50)&#10;                            is ValidationState.Error -&gt; Color(0xFFF44336)&#10;                            else -&gt; Color.White&#10;                        },&#10;                        style = androidx.compose.ui.text.TextStyle(&#10;                            shadow = androidx.compose.ui.graphics.Shadow(&#10;                                color = Color.Black,&#10;                                offset = androidx.compose.ui.geometry.Offset(2f, 2f),&#10;                                blurRadius = 4f&#10;                            )&#10;                        ),&#10;                        textAlign = TextAlign.Center&#10;                    )&#10;                }&#10;            } else {&#10;                PermissionRequestCard(onRequestPermission = {&#10;                    launcher.launch(Manifest.permission.CAMERA)&#10;                })&#10;            }&#10;        }&#10;    }&#10;&#10;    // Diálogo de éxito&#10;    if (showSuccessDialog) {&#10;        AlertDialog(&#10;            onDismissRequest = { },&#10;            title = {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    horizontalArrangement = Arrangement.Center,&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Check,&#10;                        contentDescription = &quot;Éxito&quot;,&#10;                        tint = Color(0xFF4CAF50),&#10;                        modifier = Modifier.size(32.dp)&#10;                    )&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;                    Text(&#10;                        text = &quot;¡Correcto!&quot;,&#10;                        fontSize = 24.sp,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = Color(0xFF4CAF50)&#10;                    )&#10;                }&#10;            },&#10;            text = {&#10;                Column(&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    Text(&#10;                        text = &quot;&quot;,&#10;                        fontSize = 48.sp&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    Text(&#10;                        text = &quot;Has realizado correctamente la seña: $vowel&quot;,&#10;                        textAlign = TextAlign.Center,&#10;                        fontSize = 16.sp&#10;                    )&#10;                }&#10;            },&#10;            confirmButton = {&#10;                Button(&#10;                    onClick = {&#10;                        showSuccessDialog = false&#10;                        // Si viene desde una lección, completarla&#10;                        if (leccionId != null) {&#10;                            scope.launch {&#10;                                try {&#10;                                    val usuarioId = userSession.getUserId()&#10;                                    leccionRepository.completarLeccion(usuarioId, leccionId)&#10;                                    onLeccionCompletada()&#10;                                } catch (e: Exception) {&#10;                                    // En caso de error, igual navegar de vuelta&#10;                                    onLeccionCompletada()&#10;                                }&#10;                            }&#10;                        } else {&#10;                            onNavigateBack()&#10;                        }&#10;                    },&#10;                    colors = ButtonDefaults.buttonColors(&#10;                        containerColor = Color(0xFF4CAF50)&#10;                    )&#10;                ) {&#10;                    Text(&quot;Continuar&quot;)&#10;                }&#10;            }&#10;        )&#10;    }&#10;&#10;    // Diálogo de información&#10;    if (showInfoDialog) {&#10;        AlertDialog(&#10;            onDismissRequest = { showInfoDialog = false },&#10;            title = {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Info,&#10;                        contentDescription = &quot;Información&quot;,&#10;                        tint = MaterialTheme.colorScheme.primary,&#10;                        modifier = Modifier.size(28.dp)&#10;                    )&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;                    Text(&#10;                        text = &quot;Información de Detección&quot;,&#10;                        fontSize = 20.sp,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                }&#10;            },&#10;            text = {&#10;                Column {&#10;                    Text(&#10;                        text = &quot;Letra: $vowel&quot;,&#10;                        fontSize = 16.sp,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = MaterialTheme.colorScheme.primary&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    Text(&#10;                        text = &quot;Estado: $detectionStatus&quot;,&#10;                        fontSize = 14.sp,&#10;                        color = MaterialTheme.colorScheme.onSurface&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    Text(&#10;                        text = &quot;Validación: ${when (validationResult) {&#10;                            is ValidationState.Detecting -&gt; &quot;Detectando...&quot;&#10;                            is ValidationState.Success -&gt; &quot;¡Correcto!&quot;&#10;                            is ValidationState.Error -&gt; (validationResult as ValidationState.Error).message&#10;                            is ValidationState.Waiting -&gt; &quot;Esperando seña...&quot;&#10;                        }}&quot;,&#10;                        fontSize = 14.sp,&#10;                        color = when (validationResult) {&#10;                            is ValidationState.Success -&gt; Color(0xFF4CAF50)&#10;                            is ValidationState.Error -&gt; Color(0xFFF44336)&#10;                            else -&gt; MaterialTheme.colorScheme.onSurface&#10;                        }&#10;                    )&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                    HorizontalDivider()&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                    Text(&#10;                        text = &quot; Instrucciones:&quot;,&#10;                        fontSize = 16.sp,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    Text(&#10;                        text = when (vowel.uppercase()) {&#10;                            &quot;A&quot; -&gt; &quot;Extiende el pulgar hacia afuera y cierra los demás dedos formando un puño&quot;&#10;                            &quot;E&quot; -&gt; &quot;Curva todos los dedos hacia la palma, con el pulgar cubriendo las puntas&quot;&#10;                            &quot;I&quot; -&gt; &quot;Extiende solo el meñique hacia arriba, mantén los demás dedos cerrados&quot;&#10;                            &quot;O&quot; -&gt; &quot;Forma un círculo con todos los dedos, juntando las puntas&quot;&#10;                            &quot;U&quot; -&gt; &quot;Extiende índice y meñique hacia arriba, cierra medio, anular y pulgar&quot;&#10;                            &quot;Z&quot; -&gt; &quot;Extiende solo el índice y traza una Z en el aire: línea horizontal → diagonal → línea horizontal&quot;&#10;                            &quot;AMIGO&quot; -&gt; &quot;Muy simple: muestra ambas manos, coloca una arriba y otra abajo, que estén cerca. ¡Eso es todo!&quot;&#10;                            &quot;HOLA&quot; -&gt; &quot;Abre la mano con todos los dedos extendidos y muévela lateralmente de izquierda a derecha (o viceversa) como si estuvieras saludando&quot;&#10;                            &quot;0&quot; -&gt; &quot;Forma un círculo con todos los dedos curvados, juntando las puntas de los dedos (índice, medio, anular y meñique) con la punta del pulgar&quot;&#10;                            &quot;1&quot; -&gt; &quot;Extiende solo el dedo índice hacia arriba, mantén los demás dedos cerrados&quot;&#10;                            &quot;2&quot; -&gt; &quot;Extiende los dedos índice y medio hacia arriba formando una V, cierra el pulgar, anular y meñique&quot;&#10;                            &quot;3&quot; -&gt; &quot;Extiende los dedos índice, medio y anular hacia arriba, mantén cerrados el pulgar y meñique&quot;&#10;                            &quot;4&quot; -&gt; &quot;Extiende los cuatro dedos (índice, medio, anular y meñique) hacia arriba, dobla el pulgar hacia la palma&quot;&#10;                            &quot;5&quot; -&gt; &quot;Abre completamente la mano con todos los dedos extendidos y separados&quot;&#10;                            else -&gt; &quot;Realiza la seña correspondiente seleccionada&quot;&#10;                        },&#10;                        fontSize = 14.sp,&#10;                        lineHeight = 20.sp&#10;                    )&#10;                }&#10;            },&#10;            confirmButton = {&#10;                Button(&#10;                    onClick = { showInfoDialog = false }&#10;                ) {&#10;                    Text(&quot;Entendido&quot;)&#10;                }&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun CameraPreviewWithValidation(&#10;    useFrontCamera: Boolean,&#10;    handDetector: HandDetector,&#10;    faceDetector: FaceDetector,&#10;    onImageDimensionsChanged: (Int, Int) -&gt; Unit&#10;) {&#10;    val lifecycleOwner = LocalLifecycleOwner.current&#10;    val cameraExecutor = remember { Executors.newSingleThreadExecutor() }&#10;&#10;    DisposableEffect(Unit) {&#10;        onDispose {&#10;            cameraExecutor.shutdown()&#10;        }&#10;    }&#10;&#10;    AndroidView(&#10;        factory = { ctx -&gt;&#10;            val previewView = PreviewView(ctx).apply {&#10;                layoutParams = ViewGroup.LayoutParams(&#10;                    ViewGroup.LayoutParams.MATCH_PARENT,&#10;                    ViewGroup.LayoutParams.MATCH_PARENT&#10;                )&#10;                scaleType = PreviewView.ScaleType.FIT_CENTER&#10;                implementationMode = PreviewView.ImplementationMode.COMPATIBLE&#10;            }&#10;&#10;            val cameraProviderFuture = ProcessCameraProvider.getInstance(ctx)&#10;            cameraProviderFuture.addListener({&#10;                val cameraProvider = cameraProviderFuture.get()&#10;&#10;                val preview = Preview.Builder()&#10;                    .setTargetRotation(previewView.display.rotation)&#10;                    .build()&#10;                    .also {&#10;                        it.setSurfaceProvider(previewView.surfaceProvider)&#10;                    }&#10;&#10;                val imageAnalysis = ImageAnalysis.Builder()&#10;                    .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)&#10;                    .setOutputImageFormat(ImageAnalysis.OUTPUT_IMAGE_FORMAT_RGBA_8888)&#10;                    .setTargetRotation(previewView.display.rotation)&#10;                    .build()&#10;                    .apply {&#10;                        setAnalyzer(cameraExecutor) { imageProxy -&gt;&#10;                            processImageProxyForValidation(&#10;                                imageProxy = imageProxy,&#10;                                handDetector = handDetector,&#10;                                faceDetector = faceDetector,&#10;                                onImageDimensionsChanged = onImageDimensionsChanged,&#10;                                isFrontCamera = useFrontCamera&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                val cameraSelector = if (useFrontCamera) {&#10;                    CameraSelector.DEFAULT_FRONT_CAMERA&#10;                } else {&#10;                    CameraSelector.DEFAULT_BACK_CAMERA&#10;                }&#10;&#10;                try {&#10;                    cameraProvider.unbindAll()&#10;                    cameraProvider.bindToLifecycle(&#10;                        lifecycleOwner,&#10;                        cameraSelector,&#10;                        preview,&#10;                        imageAnalysis&#10;                    )&#10;                } catch (e: Exception) {&#10;                    Log.e(&quot;VowelValidation&quot;, &quot;Camera binding failed&quot;, e)&#10;                }&#10;            }, ContextCompat.getMainExecutor(ctx))&#10;&#10;            previewView&#10;        },&#10;        modifier = Modifier.fillMaxSize(),&#10;        update = { _ -&gt;&#10;            // Actualizar cuando cambie la cámara&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun PermissionRequestCard(onRequestPermission: () -&gt; Unit) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .aspectRatio(3f / 4f),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.fillMaxSize(),&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Center&#10;        ) {&#10;            Text(&#10;                text = &quot;&quot;,&#10;                fontSize = 64.sp&#10;            )&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            Text(&#10;                text = &quot;Permiso de cámara requerido&quot;,&#10;                fontSize = 16.sp,&#10;                fontWeight = FontWeight.Bold,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            Button(&#10;                onClick = onRequestPermission,&#10;                colors = ButtonDefaults.buttonColors(&#10;                    containerColor = MaterialTheme.colorScheme.primary&#10;                )&#10;            ) {&#10;                Text(&quot;Solicitar permiso&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;private fun processImageProxyForValidation(&#10;    imageProxy: ImageProxy,&#10;    handDetector: HandDetector,&#10;    faceDetector: FaceDetector,&#10;    onImageDimensionsChanged: (Int, Int) -&gt; Unit,&#10;    isFrontCamera: Boolean = true&#10;) {&#10;    val bitmap = imageProxy.toBitmap()&#10;    val rotationDegrees = imageProxy.imageInfo.rotationDegrees&#10;&#10;    // Rotar el bitmap según la rotación del sensor&#10;    val rotatedBitmap = if (rotationDegrees != 0) {&#10;        val matrix = Matrix()&#10;        matrix.postRotate(rotationDegrees.toFloat())&#10;        if (isFrontCamera) {&#10;            matrix.postScale(-1f, 1f)&#10;        }&#10;&#10;        val rotated = Bitmap.createBitmap(&#10;            bitmap,&#10;            0,&#10;            0,&#10;            bitmap.width,&#10;            bitmap.height,&#10;            matrix,&#10;            true&#10;        )&#10;&#10;        if (rotated != bitmap) {&#10;            bitmap.recycle()&#10;        }&#10;&#10;        rotated&#10;    } else {&#10;        if (isFrontCamera) {&#10;            val matrix = Matrix()&#10;            matrix.postScale(-1f, 1f)&#10;            val flipped = Bitmap.createBitmap(&#10;                bitmap,&#10;                0,&#10;                0,&#10;                bitmap.width,&#10;                bitmap.height,&#10;                matrix,&#10;                true&#10;            )&#10;            if (flipped != bitmap) {&#10;                bitmap.recycle()&#10;            }&#10;            flipped&#10;        } else {&#10;            bitmap&#10;        }&#10;    }&#10;&#10;    val frameTime = System.currentTimeMillis()&#10;&#10;    onImageDimensionsChanged(rotatedBitmap.width, rotatedBitmap.height)&#10;&#10;    if (handDetector.isReady()) {&#10;        handDetector.detectAsync(rotatedBitmap, frameTime)&#10;    }&#10;&#10;    if (faceDetector.isReady()) {&#10;        faceDetector.detectAsync(rotatedBitmap, frameTime)&#10;    }&#10;&#10;    imageProxy.close()&#10;}&#10;&#10;private fun validateVowelSign(&#10;    handResult: HandLandmarkerResult,&#10;    vowel: String,&#10;    validator: VowelSignValidator&#10;): ValidationState {&#10;    return try {&#10;        // Manejo especial para &quot;Amigo&quot; (requiere dos manos)&#10;        if (vowel.uppercase() == &quot;AMIGO&quot;) {&#10;            val amigoResult = validator.validateSignAmigo(handResult)&#10;            return if (amigoResult.isValid) {&#10;                ValidationState.Success&#10;            } else {&#10;                ValidationState.Error(amigoResult.message)&#10;            }&#10;        }&#10;&#10;        // Manejo especial para &quot;Hola&quot; (requiere movimiento lateral)&#10;        if (vowel.uppercase() == &quot;HOLA&quot;) {&#10;            val holaResult = validator.validateSignHola(handResult)&#10;            return if (holaResult.isValid) {&#10;                ValidationState.Success&#10;            } else {&#10;                ValidationState.Error(holaResult.message)&#10;            }&#10;        }&#10;&#10;        if (handResult.landmarks().isEmpty()) {&#10;            return ValidationState.Waiting&#10;        }&#10;&#10;&#10;        // Manejo especial para la letra Z (requiere movimiento)&#10;        if (vowel.uppercase() == &quot;Z&quot;) {&#10;            val zResult = validator.validateLetterZ(handResult)&#10;            return if (zResult.isValid) {&#10;                ValidationState.Success&#10;            } else {&#10;                ValidationState.Error(zResult.message)&#10;            }&#10;        }&#10;&#10;        // Validación para las demás letras (estáticas)&#10;        val isValid = when (vowel.uppercase()) {&#10;            &quot;A&quot; -&gt; validator.validateLetterA(handResult)&#10;            &quot;E&quot; -&gt; validator.validateLetterE(handResult)&#10;            &quot;I&quot; -&gt; validator.validateLetterI(handResult)&#10;            &quot;O&quot; -&gt; validator.validateLetterO(handResult)&#10;            &quot;U&quot; -&gt; validator.validateLetterU(handResult)&#10;            &quot;0&quot; -&gt; validator.validateNumber0(handResult)&#10;            &quot;1&quot; -&gt; validator.validateNumber1(handResult)&#10;            &quot;2&quot; -&gt; validator.validateNumber2(handResult)&#10;            &quot;3&quot; -&gt; validator.validateNumber3(handResult)&#10;            &quot;4&quot; -&gt; validator.validateNumber4(handResult)&#10;            &quot;5&quot; -&gt; validator.validateNumber5(handResult)&#10;            else -&gt; false&#10;        }&#10;&#10;        if (isValid) {&#10;            ValidationState.Success&#10;        } else {&#10;            ValidationState.Error(&quot;Ajusta la posición de tus dedos&quot;)&#10;        }&#10;    } catch (e: Exception) {&#10;        ValidationState.Error(&quot;Error en la validación&quot;)&#10;    }&#10;}&#10;&#10;sealed class ValidationState {&#10;    object Detecting : ValidationState()&#10;    object Waiting : ValidationState()&#10;    object Success : ValidationState()&#10;    data class Error(val message: String) : ValidationState()&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.ecohand.presentation.senas&#10;&#10;import android.Manifest&#10;import android.content.pm.PackageManager&#10;import android.graphics.Bitmap&#10;import android.graphics.Matrix&#10;import android.util.Log&#10;import android.view.ViewGroup&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.camera.core.CameraSelector&#10;import androidx.camera.core.ImageAnalysis&#10;import androidx.camera.core.ImageProxy&#10;import androidx.camera.core.Preview&#10;import androidx.camera.lifecycle.ProcessCameraProvider&#10;import androidx.camera.view.PreviewView&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Check&#10;import androidx.compose.material.icons.filled.Refresh&#10;import androidx.compose.material.icons.filled.Info&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalLifecycleOwner&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;import androidx.core.content.ContextCompat&#10;import com.example.ecohand.ml.FaceDetector&#10;import com.example.ecohand.ml.HandDetector&#10;import com.example.ecohand.ml.VowelSignValidator&#10;import com.example.ecohand.presentation.components.DetectionOverlay&#10;import com.google.mediapipe.tasks.vision.core.RunningMode&#10;import com.google.mediapipe.tasks.vision.facelandmarker.FaceLandmarkerResult&#10;import com.google.mediapipe.tasks.vision.handlandmarker.HandLandmarkerResult&#10;import kotlinx.coroutines.launch&#10;import java.util.concurrent.Executors&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun VowelValidationScreen(&#10;    vowel: String,&#10;    leccionId: Int? = null,&#10;    onNavigateBack: () -&gt; Unit,&#10;    onLeccionCompletada: () -&gt; Unit = {}&#10;) {&#10;    val context = LocalContext.current&#10;&#10;    var hasCameraPermission by remember {&#10;        mutableStateOf(&#10;            ContextCompat.checkSelfPermission(&#10;                context,&#10;                Manifest.permission.CAMERA&#10;            ) == PackageManager.PERMISSION_GRANTED&#10;        )&#10;    }&#10;&#10;    val launcher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.RequestPermission(),&#10;        onResult = { granted -&gt;&#10;            hasCameraPermission = granted&#10;        }&#10;    )&#10;&#10;    var useFrontCamera by remember { mutableStateOf(true) }&#10;    var handResults by remember { mutableStateOf&lt;HandLandmarkerResult?&gt;(null) }&#10;    var faceResults by remember { mutableStateOf&lt;FaceLandmarkerResult?&gt;(null) }&#10;    var imageWidth by remember { mutableStateOf(640) }&#10;    var imageHeight by remember { mutableStateOf(480) }&#10;    var detectionStatus by remember { mutableStateOf(&quot;Inicializando...&quot;) }&#10;    var validationResult by remember { mutableStateOf&lt;ValidationState&gt;(ValidationState.Detecting) }&#10;    var showSuccessDialog by remember { mutableStateOf(false) }&#10;    var showInfoDialog by remember { mutableStateOf(false) }&#10;&#10;    // Detectores y validador&#10;    val handDetector = remember {&#10;        HandDetector(&#10;            context = context,&#10;            runningMode = RunningMode.LIVE_STREAM,&#10;            maxNumHands = 2 // Detectar hasta 2 manos (necesario para señas como &quot;Amigo&quot;)&#10;        )&#10;    }&#10;&#10;    val faceDetector = remember {&#10;        FaceDetector(&#10;            context = context,&#10;            runningMode = RunningMode.LIVE_STREAM,&#10;            maxNumFaces = 1&#10;        )&#10;    }&#10;&#10;    val vowelValidator = remember { VowelSignValidator() }&#10;&#10;    // Scope para completar la lección&#10;    val scope = rememberCoroutineScope()&#10;    val database = remember { com.example.ecohand.data.local.database.EcoHandDatabase.getDatabase(context) }&#10;    val leccionRepository = remember {&#10;        com.example.ecohand.data.repository.LeccionRepository(&#10;            database.leccionDao(),&#10;            database.progresoLeccionDao(),&#10;            database.estadisticasUsuarioDao()&#10;        )&#10;    }&#10;    val userSession = remember { com.example.ecohand.data.session.UserSession.getInstance(context) }&#10;&#10;    // Inicializar detectores&#10;    LaunchedEffect(Unit) {&#10;        if (!hasCameraPermission) {&#10;            launcher.launch(Manifest.permission.CAMERA)&#10;        }&#10;&#10;        val handInit = handDetector.initialize { result, _ -&gt;&#10;            handResults = result&#10;            // Validar la seña automáticamente&#10;            validationResult = validateVowelSign(result, vowel, vowelValidator)&#10;        }&#10;&#10;        val faceInit = faceDetector.initialize { result, _ -&gt;&#10;            faceResults = result&#10;        }&#10;&#10;        detectionStatus = when {&#10;            handInit &amp;&amp; faceInit -&gt; &quot;✓ Detectores listos&quot;&#10;            handInit -&gt; &quot;⚠ Solo manos listo&quot;&#10;            faceInit -&gt; &quot;⚠ Solo rostro listo&quot;&#10;            else -&gt; &quot;✗ Error al inicializar&quot;&#10;        }&#10;    }&#10;&#10;    // Mostrar diálogo de éxito cuando se valide correctamente&#10;    LaunchedEffect(validationResult) {&#10;        if (validationResult is ValidationState.Success) {&#10;            showSuccessDialog = true&#10;        }&#10;    }&#10;&#10;    // Limpiar recursos&#10;    DisposableEffect(Unit) {&#10;        onDispose {&#10;            handDetector.close()&#10;            faceDetector.close()&#10;            // Limpiar trayectorias de letras con movimiento&#10;            vowelValidator.resetZTrajectory()&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = {&#10;                    Text(&#10;                        text = &quot;Validar: $vowel&quot;,&#10;                        fontWeight = FontWeight.Bold,&#10;                        fontSize = 18.sp&#10;                    )&#10;                },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onNavigateBack) {&#10;                        Icon(&#10;                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                            contentDescription = &quot;Volver&quot;&#10;                        )&#10;                    }&#10;                },&#10;                actions = {&#10;                    // Botón de información&#10;                    IconButton(onClick = { showInfoDialog = true }) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Info,&#10;                            contentDescription = &quot;Ver información&quot;&#10;                        )&#10;                    }&#10;                    // Botón para cambiar cámara&#10;                    IconButton(onClick = { useFrontCamera = !useFrontCamera }) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Refresh,&#10;                            contentDescription = &quot;Cambiar cámara&quot;&#10;                        )&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = MaterialTheme.colorScheme.primary,&#10;                    titleContentColor = MaterialTheme.colorScheme.onPrimary,&#10;                    navigationIconContentColor = MaterialTheme.colorScheme.onPrimary,&#10;                    actionIconContentColor = MaterialTheme.colorScheme.onPrimary&#10;                )&#10;            )&#10;        }&#10;    ) { paddingValues -&gt;&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues)&#10;                .background(MaterialTheme.colorScheme.background)&#10;        ) {&#10;            // Vista de cámara con overlay ocupando todo el espacio&#10;            if (hasCameraPermission) {&#10;                // Cámara con key para forzar recomposición al cambiar de cámara&#10;                key(useFrontCamera) {&#10;                    CameraPreviewWithValidation(&#10;                        useFrontCamera = useFrontCamera,&#10;                        handDetector = handDetector,&#10;                        faceDetector = faceDetector,&#10;                        onImageDimensionsChanged = { width, height -&gt;&#10;                            imageWidth = width&#10;                            imageHeight = height&#10;                        }&#10;                    )&#10;                }&#10;&#10;                // Overlay de detecciones&#10;                DetectionOverlay(&#10;                    handResults = handResults,&#10;                    faceResults = faceResults,&#10;                    imageWidth = imageWidth,&#10;                    imageHeight = imageHeight,&#10;                    modifier = Modifier.fillMaxSize()&#10;                )&#10;&#10;                // Overlay de estado en la parte superior (texto sin fondo)&#10;                Column(&#10;                    modifier = Modifier&#10;                        .align(Alignment.TopCenter)&#10;                        .fillMaxWidth()&#10;                        .padding(16.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    // Estado de validación (texto con sombra para visibilidad)&#10;                    Text(&#10;                        text = when (validationResult) {&#10;                            is ValidationState.Detecting -&gt; &quot; Detectando...&quot;&#10;                            is ValidationState.Success -&gt; &quot;✅ ¡Correcto!&quot;&#10;                            is ValidationState.Error -&gt; &quot;❌ ${(validationResult as ValidationState.Error).message}&quot;&#10;                            is ValidationState.Waiting -&gt; &quot;⏳ Esperando seña...&quot;&#10;                        },&#10;                        fontSize = 20.sp,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = when (validationResult) {&#10;                            is ValidationState.Success -&gt; Color(0xFF4CAF50)&#10;                            is ValidationState.Error -&gt; Color(0xFFF44336)&#10;                            else -&gt; Color.White&#10;                        },&#10;                        style = androidx.compose.ui.text.TextStyle(&#10;                            shadow = androidx.compose.ui.graphics.Shadow(&#10;                                color = Color.Black,&#10;                                offset = androidx.compose.ui.geometry.Offset(2f, 2f),&#10;                                blurRadius = 4f&#10;                            )&#10;                        ),&#10;                        textAlign = TextAlign.Center&#10;                    )&#10;                }&#10;            } else {&#10;                PermissionRequestCard(onRequestPermission = {&#10;                    launcher.launch(Manifest.permission.CAMERA)&#10;                })&#10;            }&#10;        }&#10;    }&#10;&#10;    // Diálogo de éxito&#10;    if (showSuccessDialog) {&#10;        AlertDialog(&#10;            onDismissRequest = { },&#10;            title = {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    horizontalArrangement = Arrangement.Center,&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Check,&#10;                        contentDescription = &quot;Éxito&quot;,&#10;                        tint = Color(0xFF4CAF50),&#10;                        modifier = Modifier.size(32.dp)&#10;                    )&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;                    Text(&#10;                        text = &quot;¡Correcto!&quot;,&#10;                        fontSize = 24.sp,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = Color(0xFF4CAF50)&#10;                    )&#10;                }&#10;            },&#10;            text = {&#10;                Column(&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    Text(&#10;                        text = &quot;&quot;,&#10;                        fontSize = 48.sp&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    Text(&#10;                        text = &quot;Has realizado correctamente la seña: $vowel&quot;,&#10;                        textAlign = TextAlign.Center,&#10;                        fontSize = 16.sp&#10;                    )&#10;                }&#10;            },&#10;            confirmButton = {&#10;                Button(&#10;                    onClick = {&#10;                        showSuccessDialog = false&#10;                        // Si viene desde una lección (leccionId &gt; 0), marcar seña como completada&#10;                        if (leccionId != null &amp;&amp; leccionId &gt; 0) {&#10;                            // Marcar esta seña específica como completada&#10;                            com.example.ecohand.data.session.LeccionValidacionState.marcarSenaCompletada(leccionId, vowel)&#10;                            // Volver a la pantalla anterior (lista de señas)&#10;                            onNavigateBack()&#10;                        } else if (leccionId == 0) {&#10;                            // Modo multi-validación: solo llamar callback sin guardar&#10;                            onLeccionCompletada()&#10;                        } else {&#10;                            // Modo normal: volver atrás&#10;                            onNavigateBack()&#10;                        }&#10;                    },&#10;                    colors = ButtonDefaults.buttonColors(&#10;                        containerColor = Color(0xFF4CAF50)&#10;                    )&#10;                ) {&#10;                    Text(&quot;Continuar&quot;)&#10;                }&#10;            }&#10;        )&#10;    }&#10;&#10;    // Diálogo de información&#10;    if (showInfoDialog) {&#10;        AlertDialog(&#10;            onDismissRequest = { showInfoDialog = false },&#10;            title = {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Info,&#10;                        contentDescription = &quot;Información&quot;,&#10;                        tint = MaterialTheme.colorScheme.primary,&#10;                        modifier = Modifier.size(28.dp)&#10;                    )&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;                    Text(&#10;                        text = &quot;Información de Detección&quot;,&#10;                        fontSize = 20.sp,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                }&#10;            },&#10;            text = {&#10;                Column {&#10;                    Text(&#10;                        text = &quot;Letra: $vowel&quot;,&#10;                        fontSize = 16.sp,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = MaterialTheme.colorScheme.primary&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    Text(&#10;                        text = &quot;Estado: $detectionStatus&quot;,&#10;                        fontSize = 14.sp,&#10;                        color = MaterialTheme.colorScheme.onSurface&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    Text(&#10;                        text = &quot;Validación: ${when (validationResult) {&#10;                            is ValidationState.Detecting -&gt; &quot;Detectando...&quot;&#10;                            is ValidationState.Success -&gt; &quot;¡Correcto!&quot;&#10;                            is ValidationState.Error -&gt; (validationResult as ValidationState.Error).message&#10;                            is ValidationState.Waiting -&gt; &quot;Esperando seña...&quot;&#10;                        }}&quot;,&#10;                        fontSize = 14.sp,&#10;                        color = when (validationResult) {&#10;                            is ValidationState.Success -&gt; Color(0xFF4CAF50)&#10;                            is ValidationState.Error -&gt; Color(0xFFF44336)&#10;                            else -&gt; MaterialTheme.colorScheme.onSurface&#10;                        }&#10;                    )&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                    HorizontalDivider()&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                    Text(&#10;                        text = &quot; Instrucciones:&quot;,&#10;                        fontSize = 16.sp,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    Text(&#10;                        text = when (vowel.uppercase()) {&#10;                            &quot;A&quot; -&gt; &quot;Extiende el pulgar hacia afuera y cierra los demás dedos formando un puño&quot;&#10;                            &quot;E&quot; -&gt; &quot;Curva todos los dedos hacia la palma, con el pulgar cubriendo las puntas&quot;&#10;                            &quot;I&quot; -&gt; &quot;Extiende solo el meñique hacia arriba, mantén los demás dedos cerrados&quot;&#10;                            &quot;O&quot; -&gt; &quot;Forma un círculo con todos los dedos, juntando las puntas&quot;&#10;                            &quot;U&quot; -&gt; &quot;Extiende índice y meñique hacia arriba, cierra medio, anular y pulgar&quot;&#10;                            &quot;Z&quot; -&gt; &quot;Extiende solo el índice y traza una Z en el aire: línea horizontal → diagonal → línea horizontal&quot;&#10;                            &quot;AMIGO&quot; -&gt; &quot;Muy simple: muestra ambas manos, coloca una arriba y otra abajo, que estén cerca. ¡Eso es todo!&quot;&#10;                            &quot;HOLA&quot; -&gt; &quot;Abre la mano con todos los dedos extendidos y muévela lateralmente de izquierda a derecha (o viceversa) como si estuvieras saludando&quot;&#10;                            &quot;0&quot; -&gt; &quot;Forma un círculo con todos los dedos curvados, juntando las puntas de los dedos (índice, medio, anular y meñique) con la punta del pulgar&quot;&#10;                            &quot;1&quot; -&gt; &quot;Extiende solo el dedo índice hacia arriba, mantén los demás dedos cerrados&quot;&#10;                            &quot;2&quot; -&gt; &quot;Extiende los dedos índice y medio hacia arriba formando una V, cierra el pulgar, anular y meñique&quot;&#10;                            &quot;3&quot; -&gt; &quot;Extiende los dedos índice, medio y anular hacia arriba, mantén cerrados el pulgar y meñique&quot;&#10;                            &quot;4&quot; -&gt; &quot;Extiende los cuatro dedos (índice, medio, anular y meñique) hacia arriba, dobla el pulgar hacia la palma&quot;&#10;                            &quot;5&quot; -&gt; &quot;Abre completamente la mano con todos los dedos extendidos y separados&quot;&#10;                            else -&gt; &quot;Realiza la seña correspondiente seleccionada&quot;&#10;                        },&#10;                        fontSize = 14.sp,&#10;                        lineHeight = 20.sp&#10;                    )&#10;                }&#10;            },&#10;            confirmButton = {&#10;                Button(&#10;                    onClick = { showInfoDialog = false }&#10;                ) {&#10;                    Text(&quot;Entendido&quot;)&#10;                }&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun CameraPreviewWithValidation(&#10;    useFrontCamera: Boolean,&#10;    handDetector: HandDetector,&#10;    faceDetector: FaceDetector,&#10;    onImageDimensionsChanged: (Int, Int) -&gt; Unit&#10;) {&#10;    val lifecycleOwner = LocalLifecycleOwner.current&#10;    val cameraExecutor = remember { Executors.newSingleThreadExecutor() }&#10;&#10;    DisposableEffect(Unit) {&#10;        onDispose {&#10;            cameraExecutor.shutdown()&#10;        }&#10;    }&#10;&#10;    AndroidView(&#10;        factory = { ctx -&gt;&#10;            val previewView = PreviewView(ctx).apply {&#10;                layoutParams = ViewGroup.LayoutParams(&#10;                    ViewGroup.LayoutParams.MATCH_PARENT,&#10;                    ViewGroup.LayoutParams.MATCH_PARENT&#10;                )&#10;                scaleType = PreviewView.ScaleType.FIT_CENTER&#10;                implementationMode = PreviewView.ImplementationMode.COMPATIBLE&#10;            }&#10;&#10;            val cameraProviderFuture = ProcessCameraProvider.getInstance(ctx)&#10;            cameraProviderFuture.addListener({&#10;                val cameraProvider = cameraProviderFuture.get()&#10;&#10;                val preview = Preview.Builder()&#10;                    .setTargetRotation(previewView.display.rotation)&#10;                    .build()&#10;                    .also {&#10;                        it.setSurfaceProvider(previewView.surfaceProvider)&#10;                    }&#10;&#10;                val imageAnalysis = ImageAnalysis.Builder()&#10;                    .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)&#10;                    .setOutputImageFormat(ImageAnalysis.OUTPUT_IMAGE_FORMAT_RGBA_8888)&#10;                    .setTargetRotation(previewView.display.rotation)&#10;                    .build()&#10;                    .apply {&#10;                        setAnalyzer(cameraExecutor) { imageProxy -&gt;&#10;                            processImageProxyForValidation(&#10;                                imageProxy = imageProxy,&#10;                                handDetector = handDetector,&#10;                                faceDetector = faceDetector,&#10;                                onImageDimensionsChanged = onImageDimensionsChanged,&#10;                                isFrontCamera = useFrontCamera&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                val cameraSelector = if (useFrontCamera) {&#10;                    CameraSelector.DEFAULT_FRONT_CAMERA&#10;                } else {&#10;                    CameraSelector.DEFAULT_BACK_CAMERA&#10;                }&#10;&#10;                try {&#10;                    cameraProvider.unbindAll()&#10;                    cameraProvider.bindToLifecycle(&#10;                        lifecycleOwner,&#10;                        cameraSelector,&#10;                        preview,&#10;                        imageAnalysis&#10;                    )&#10;                } catch (e: Exception) {&#10;                    Log.e(&quot;VowelValidation&quot;, &quot;Camera binding failed&quot;, e)&#10;                }&#10;            }, ContextCompat.getMainExecutor(ctx))&#10;&#10;            previewView&#10;        },&#10;        modifier = Modifier.fillMaxSize(),&#10;        update = { _ -&gt;&#10;            // Actualizar cuando cambie la cámara&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun PermissionRequestCard(onRequestPermission: () -&gt; Unit) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .aspectRatio(3f / 4f),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.fillMaxSize(),&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Center&#10;        ) {&#10;            Text(&#10;                text = &quot;&quot;,&#10;                fontSize = 64.sp&#10;            )&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            Text(&#10;                text = &quot;Permiso de cámara requerido&quot;,&#10;                fontSize = 16.sp,&#10;                fontWeight = FontWeight.Bold,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            Button(&#10;                onClick = onRequestPermission,&#10;                colors = ButtonDefaults.buttonColors(&#10;                    containerColor = MaterialTheme.colorScheme.primary&#10;                )&#10;            ) {&#10;                Text(&quot;Solicitar permiso&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;private fun processImageProxyForValidation(&#10;    imageProxy: ImageProxy,&#10;    handDetector: HandDetector,&#10;    faceDetector: FaceDetector,&#10;    onImageDimensionsChanged: (Int, Int) -&gt; Unit,&#10;    isFrontCamera: Boolean = true&#10;) {&#10;    val bitmap = imageProxy.toBitmap()&#10;    val rotationDegrees = imageProxy.imageInfo.rotationDegrees&#10;&#10;    // Rotar el bitmap según la rotación del sensor&#10;    val rotatedBitmap = if (rotationDegrees != 0) {&#10;        val matrix = Matrix()&#10;        matrix.postRotate(rotationDegrees.toFloat())&#10;        if (isFrontCamera) {&#10;            matrix.postScale(-1f, 1f)&#10;        }&#10;&#10;        val rotated = Bitmap.createBitmap(&#10;            bitmap,&#10;            0,&#10;            0,&#10;            bitmap.width,&#10;            bitmap.height,&#10;            matrix,&#10;            true&#10;        )&#10;&#10;        if (rotated != bitmap) {&#10;            bitmap.recycle()&#10;        }&#10;&#10;        rotated&#10;    } else {&#10;        if (isFrontCamera) {&#10;            val matrix = Matrix()&#10;            matrix.postScale(-1f, 1f)&#10;            val flipped = Bitmap.createBitmap(&#10;                bitmap,&#10;                0,&#10;                0,&#10;                bitmap.width,&#10;                bitmap.height,&#10;                matrix,&#10;                true&#10;            )&#10;            if (flipped != bitmap) {&#10;                bitmap.recycle()&#10;            }&#10;            flipped&#10;        } else {&#10;            bitmap&#10;        }&#10;    }&#10;&#10;    val frameTime = System.currentTimeMillis()&#10;&#10;    onImageDimensionsChanged(rotatedBitmap.width, rotatedBitmap.height)&#10;&#10;    if (handDetector.isReady()) {&#10;        handDetector.detectAsync(rotatedBitmap, frameTime)&#10;    }&#10;&#10;    if (faceDetector.isReady()) {&#10;        faceDetector.detectAsync(rotatedBitmap, frameTime)&#10;    }&#10;&#10;    imageProxy.close()&#10;}&#10;&#10;private fun validateVowelSign(&#10;    handResult: HandLandmarkerResult,&#10;    vowel: String,&#10;    validator: VowelSignValidator&#10;): ValidationState {&#10;    return try {&#10;        // Manejo especial para &quot;Amigo&quot; (requiere dos manos)&#10;        if (vowel.uppercase() == &quot;AMIGO&quot;) {&#10;            val amigoResult = validator.validateSignAmigo(handResult)&#10;            return if (amigoResult.isValid) {&#10;                ValidationState.Success&#10;            } else {&#10;                ValidationState.Error(amigoResult.message)&#10;            }&#10;        }&#10;&#10;        // Manejo especial para &quot;Hola&quot; (requiere movimiento lateral)&#10;        if (vowel.uppercase() == &quot;HOLA&quot;) {&#10;            val holaResult = validator.validateSignHola(handResult)&#10;            return if (holaResult.isValid) {&#10;                ValidationState.Success&#10;            } else {&#10;                ValidationState.Error(holaResult.message)&#10;            }&#10;        }&#10;&#10;        if (handResult.landmarks().isEmpty()) {&#10;            return ValidationState.Waiting&#10;        }&#10;&#10;&#10;        // Manejo especial para la letra Z (requiere movimiento)&#10;        if (vowel.uppercase() == &quot;Z&quot;) {&#10;            val zResult = validator.validateLetterZ(handResult)&#10;            return if (zResult.isValid) {&#10;                ValidationState.Success&#10;            } else {&#10;                ValidationState.Error(zResult.message)&#10;            }&#10;        }&#10;&#10;        // Validación para las demás letras (estáticas)&#10;        val isValid = when (vowel.uppercase()) {&#10;            &quot;A&quot; -&gt; validator.validateLetterA(handResult)&#10;            &quot;E&quot; -&gt; validator.validateLetterE(handResult)&#10;            &quot;I&quot; -&gt; validator.validateLetterI(handResult)&#10;            &quot;O&quot; -&gt; validator.validateLetterO(handResult)&#10;            &quot;U&quot; -&gt; validator.validateLetterU(handResult)&#10;            &quot;0&quot; -&gt; validator.validateNumber0(handResult)&#10;            &quot;1&quot; -&gt; validator.validateNumber1(handResult)&#10;            &quot;2&quot; -&gt; validator.validateNumber2(handResult)&#10;            &quot;3&quot; -&gt; validator.validateNumber3(handResult)&#10;            &quot;4&quot; -&gt; validator.validateNumber4(handResult)&#10;            &quot;5&quot; -&gt; validator.validateNumber5(handResult)&#10;            else -&gt; false&#10;        }&#10;&#10;        if (isValid) {&#10;            ValidationState.Success&#10;        } else {&#10;            ValidationState.Error(&quot;Ajusta la posición de tus dedos&quot;)&#10;        }&#10;    } catch (e: Exception) {&#10;        ValidationState.Error(&quot;Error en la validación&quot;)&#10;    }&#10;}&#10;&#10;sealed class ValidationState {&#10;    object Detecting : ValidationState()&#10;    object Waiting : ValidationState()&#10;    object Success : ValidationState()&#10;    data class Error(val message: String) : ValidationState()&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>