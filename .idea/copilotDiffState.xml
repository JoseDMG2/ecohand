<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/ecohand/presentation/juegos/JuegosViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/ecohand/presentation/juegos/JuegosViewModel.kt" />
              <option name="originalContent" value="package com.example.ecohand.presentation.juegos&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.ecohand.data.local.entity.PartidaJuegoEntity&#10;import com.example.ecohand.data.local.entity.SenaEntity&#10;import com.example.ecohand.data.repository.JuegoRepository&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;data class Desafio(&#10;    val sena: SenaEntity,&#10;    val respuesta: String,&#10;    val letrasDisponibles: List&lt;Char&gt;,&#10;    val espaciosRespuesta: List&lt;Char?&gt; = List(respuesta.length) { null },&#10;    val letrasUsadas: List&lt;Boolean&gt; = List(letrasDisponibles.size) { false }&#10;)&#10;&#10;data class JuegosUiState(&#10;    val isLoading: Boolean = true,&#10;    val desafioActual: Desafio? = null,&#10;    val numeroDesafio: Int = 1,&#10;    val totalDesafios: Int = 5,&#10;    val partidaId: Int? = null,&#10;    val desafiosCorrectos: Int = 0,&#10;    val puntosGanados: Int = 0,&#10;    val mostrarResultado: Boolean = false,&#10;    val esCorrecto: Boolean = false,&#10;    val juegoCompletado: Boolean = false,&#10;    val errorMessage: String? = null&#10;)&#10;&#10;class JuegosViewModel(&#10;    private val juegoRepository: JuegoRepository,&#10;    private val usuarioId: Int&#10;) : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow(JuegosUiState())&#10;    val uiState: StateFlow&lt;JuegosUiState&gt; = _uiState.asStateFlow()&#10;&#10;    private var senasUsadas = mutableListOf&lt;Int&gt;()&#10;    private var todasLasSenas = listOf&lt;SenaEntity&gt;()&#10;&#10;    init {&#10;        iniciarJuego()&#10;    }&#10;&#10;    fun iniciarJuego() {&#10;        viewModelScope.launch {&#10;            try {&#10;                _uiState.value = _uiState.value.copy(isLoading = true)&#10;&#10;                // Obtener todas las señas&#10;                todasLasSenas = juegoRepository.getAllSenas()&#10;                senasUsadas.clear()&#10;&#10;                // Verificar si hay señas disponibles&#10;                if (todasLasSenas.isEmpty()) {&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isLoading = false,&#10;                        errorMessage = &quot;No hay señas disponibles. Por favor, verifica la base de datos.&quot;&#10;                    )&#10;                    return@launch&#10;                }&#10;&#10;                // Crear nueva partida&#10;                val partidaId = juegoRepository.crearPartida(usuarioId)&#10;&#10;                // Cargar primer desafío&#10;                val primerDesafio = generarDesafio()&#10;                if (primerDesafio == null) {&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isLoading = false,&#10;                        errorMessage = &quot;Error al generar desafío&quot;&#10;                    )&#10;                    return@launch&#10;                }&#10;&#10;                _uiState.value = JuegosUiState(&#10;                    isLoading = false,&#10;                    partidaId = partidaId.toInt(),&#10;                    numeroDesafio = 1,&#10;                    desafioActual = primerDesafio&#10;                )&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    errorMessage = &quot;Error al iniciar juego: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun generarDesafio(): Desafio? {&#10;        // Verificar que hay señas disponibles&#10;        if (todasLasSenas.isEmpty()) {&#10;            return null&#10;        }&#10;&#10;        // Filtrar señas no usadas&#10;        val senasDisponibles = todasLasSenas.filter { it.id !in senasUsadas }&#10;&#10;        // Si se acabaron las señas, reiniciar la lista&#10;        val senaParaUsar = if (senasDisponibles.isEmpty()) {&#10;            senasUsadas.clear()&#10;            todasLasSenas.random()&#10;        } else {&#10;            senasDisponibles.random()&#10;        }&#10;&#10;        senasUsadas.add(senaParaUsar.id)&#10;&#10;        val respuesta = senaParaUsar.nombre.uppercase()&#10;&#10;        // Generar letras disponibles (la respuesta + letras adicionales)&#10;        val letrasRespuesta = respuesta.toSet()&#10;        val letrasAdicionales = ('A'..'Z').filter { it !in letrasRespuesta }&#10;            .shuffled()&#10;            .take(maxOf(0, 8 - respuesta.length))&#10;&#10;        val todasLetras = (letrasRespuesta + letrasAdicionales)&#10;            .shuffled()&#10;            .take(8) // Máximo 8 letras&#10;&#10;        return Desafio(&#10;            sena = senaParaUsar,&#10;            respuesta = respuesta,&#10;            letrasDisponibles = todasLetras&#10;        )&#10;    }&#10;&#10;    fun onLetraClick(index: Int) {&#10;        val currentState = _uiState.value&#10;        val desafio = currentState.desafioActual ?: return&#10;&#10;        // Si la letra ya fue usada, no hacer nada&#10;        if (desafio.letrasUsadas[index]) return&#10;&#10;        // Encontrar el primer espacio vacío&#10;        val primerEspacioVacio = desafio.espaciosRespuesta.indexOfFirst { it == null }&#10;&#10;        if (primerEspacioVacio != -1) {&#10;            val letra = desafio.letrasDisponibles[index]&#10;            val nuevosEspacios = desafio.espaciosRespuesta.toMutableList()&#10;            nuevosEspacios[primerEspacioVacio] = letra&#10;&#10;            val nuevasLetrasUsadas = desafio.letrasUsadas.toMutableList()&#10;            nuevasLetrasUsadas[index] = true&#10;&#10;            val desafioActualizado = desafio.copy(&#10;                espaciosRespuesta = nuevosEspacios,&#10;                letrasUsadas = nuevasLetrasUsadas&#10;            )&#10;&#10;            _uiState.value = currentState.copy(desafioActual = desafioActualizado)&#10;        }&#10;    }&#10;&#10;    fun onEspacioClick(espacioIndex: Int) {&#10;        val currentState = _uiState.value&#10;        val desafio = currentState.desafioActual ?: return&#10;&#10;        val letraEnEspacio = desafio.espaciosRespuesta[espacioIndex] ?: return&#10;&#10;        // Encontrar el índice original de esta letra&#10;        val letraIndex = desafio.letrasDisponibles.indexOf(letraEnEspacio)&#10;&#10;        if (letraIndex != -1) {&#10;            val nuevosEspacios = desafio.espaciosRespuesta.toMutableList()&#10;            nuevosEspacios[espacioIndex] = null&#10;&#10;            val nuevasLetrasUsadas = desafio.letrasUsadas.toMutableList()&#10;            nuevasLetrasUsadas[letraIndex] = false&#10;&#10;            val desafioActualizado = desafio.copy(&#10;                espaciosRespuesta = nuevosEspacios,&#10;                letrasUsadas = nuevasLetrasUsadas&#10;            )&#10;&#10;            _uiState.value = currentState.copy(desafioActual = desafioActualizado)&#10;        }&#10;    }&#10;&#10;    fun verificarRespuesta() {&#10;        val currentState = _uiState.value&#10;        val desafio = currentState.desafioActual ?: return&#10;&#10;        // Verificar si todos los espacios están llenos&#10;        if (desafio.espaciosRespuesta.any { it == null }) {&#10;            return&#10;        }&#10;&#10;        val respuestaUsuario = desafio.espaciosRespuesta.joinToString(&quot;&quot;)&#10;        val esCorrecto = respuestaUsuario == desafio.respuesta&#10;&#10;        if (esCorrecto) {&#10;            // Respuesta correcta&#10;            val nuevosDesafiosCorrectos = currentState.desafiosCorrectos + 1&#10;            val puntos = 20 // 20 puntos por respuesta correcta&#10;&#10;            viewModelScope.launch {&#10;                // Actualizar partida&#10;                currentState.partidaId?.let { partidaId -&gt;&#10;                    val partida = PartidaJuegoEntity(&#10;                        id = partidaId,&#10;                        usuarioId = usuarioId,&#10;                        desafiosCompletados = currentState.numeroDesafio,&#10;                        desafiosCorrectos = nuevosDesafiosCorrectos,&#10;                        desafiosIncorrectos = currentState.numeroDesafio - nuevosDesafiosCorrectos,&#10;                        puntosGanados = currentState.puntosGanados + puntos&#10;                    )&#10;                    juegoRepository.actualizarPartida(partida)&#10;                }&#10;            }&#10;&#10;            _uiState.value = currentState.copy(&#10;                mostrarResultado = true,&#10;                esCorrecto = true,&#10;                desafiosCorrectos = nuevosDesafiosCorrectos,&#10;                puntosGanados = currentState.puntosGanados + puntos&#10;            )&#10;        } else {&#10;            // Respuesta incorrecta&#10;            _uiState.value = currentState.copy(&#10;                mostrarResultado = true,&#10;                esCorrecto = false&#10;            )&#10;        }&#10;    }&#10;&#10;    fun continuarJuego() {&#10;        val currentState = _uiState.value&#10;&#10;        if (currentState.esCorrecto) {&#10;            // Si respondió correctamente, avanzar al siguiente desafío&#10;            if (currentState.numeroDesafio &gt;= currentState.totalDesafios) {&#10;                // Juego completado&#10;                finalizarJuego()&#10;            } else {&#10;                // Siguiente desafío&#10;                val nuevoDesafio = generarDesafio()&#10;                if (nuevoDesafio != null) {&#10;                    _uiState.value = currentState.copy(&#10;                        desafioActual = nuevoDesafio,&#10;                        numeroDesafio = currentState.numeroDesafio + 1,&#10;                        mostrarResultado = false,&#10;                        esCorrecto = false&#10;                    )&#10;                } else {&#10;                    _uiState.value = currentState.copy(&#10;                        errorMessage = &quot;Error al generar el siguiente desafío&quot;&#10;                    )&#10;                }&#10;            }&#10;        } else {&#10;            // Si respondió incorrectamente, limpiar espacios para reintentar&#10;            val desafio = currentState.desafioActual ?: return&#10;            _uiState.value = currentState.copy(&#10;                desafioActual = desafio.copy(&#10;                    espaciosRespuesta = List(desafio.respuesta.length) { null },&#10;                    letrasUsadas = List(desafio.letrasDisponibles.size) { false }&#10;                ),&#10;                mostrarResultado = false,&#10;                esCorrecto = false&#10;            )&#10;        }&#10;    }&#10;&#10;    private fun finalizarJuego() {&#10;        viewModelScope.launch {&#10;            val currentState = _uiState.value&#10;            currentState.partidaId?.let { partidaId -&gt;&#10;                juegoRepository.completarPartida(partidaId, usuarioId)&#10;            }&#10;&#10;            _uiState.value = currentState.copy(&#10;                juegoCompletado = true,&#10;                mostrarResultado = false&#10;            )&#10;        }&#10;    }&#10;&#10;    fun reiniciarJuego() {&#10;        iniciarJuego()&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.example.ecohand.presentation.juegos&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.ecohand.data.local.entity.PartidaJuegoEntity&#10;import com.example.ecohand.data.local.entity.SenaEntity&#10;import com.example.ecohand.data.repository.JuegoRepository&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;data class Desafio(&#10;    val sena: SenaEntity,&#10;    val respuesta: String,&#10;    val letrasDisponibles: List&lt;Char&gt;,&#10;    val espaciosRespuesta: List&lt;Char?&gt; = List(respuesta.length) { null },&#10;    val letrasUsadas: List&lt;Boolean&gt; = List(letrasDisponibles.size) { false }&#10;)&#10;&#10;data class JuegosUiState(&#10;    val isLoading: Boolean = true,&#10;    val desafioActual: Desafio? = null,&#10;    val numeroDesafio: Int = 1,&#10;    val totalDesafios: Int = 5,&#10;    val partidaId: Int? = null,&#10;    val desafiosCorrectos: Int = 0,&#10;    val puntosGanados: Int = 0,&#10;    val mostrarResultado: Boolean = false,&#10;    val esCorrecto: Boolean = false,&#10;    val juegoCompletado: Boolean = false,&#10;    val errorMessage: String? = null&#10;)&#10;&#10;class JuegosViewModel(&#10;    private val juegoRepository: JuegoRepository,&#10;    private val usuarioId: Int&#10;) : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow(JuegosUiState())&#10;    val uiState: StateFlow&lt;JuegosUiState&gt; = _uiState.asStateFlow()&#10;&#10;    private var senasUsadas = mutableListOf&lt;Int&gt;()&#10;    private var todasLasSenas = listOf&lt;SenaEntity&gt;()&#10;&#10;    init {&#10;        iniciarJuego()&#10;    }&#10;&#10;    fun iniciarJuego() {&#10;        viewModelScope.launch {&#10;            try {&#10;                _uiState.value = _uiState.value.copy(isLoading = true)&#10;&#10;                // Obtener todas las señas&#10;                todasLasSenas = juegoRepository.getAllSenas()&#10;                senasUsadas.clear()&#10;&#10;                // Verificar si hay señas disponibles&#10;                if (todasLasSenas.isEmpty()) {&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isLoading = false,&#10;                        errorMessage = &quot;No hay señas disponibles. Por favor, verifica la base de datos.&quot;&#10;                    )&#10;                    return@launch&#10;                }&#10;&#10;                // Crear nueva partida&#10;                val partidaId = juegoRepository.crearPartida(usuarioId)&#10;&#10;                // Cargar primer desafío&#10;                val primerDesafio = generarDesafio()&#10;                if (primerDesafio == null) {&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isLoading = false,&#10;                        errorMessage = &quot;Error al generar desafío&quot;&#10;                    )&#10;                    return@launch&#10;                }&#10;&#10;                _uiState.value = JuegosUiState(&#10;                    isLoading = false,&#10;                    partidaId = partidaId.toInt(),&#10;                    numeroDesafio = 1,&#10;                    desafioActual = primerDesafio&#10;                )&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    errorMessage = &quot;Error al iniciar juego: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun generarDesafio(): Desafio? {&#10;        // Verificar que hay señas disponibles&#10;        if (todasLasSenas.isEmpty()) {&#10;            return null&#10;        }&#10;&#10;        // Filtrar señas no usadas&#10;        val senasDisponibles = todasLasSenas.filter { it.id !in senasUsadas }&#10;&#10;        // Si se acabaron las señas, reiniciar la lista&#10;        val senaParaUsar = if (senasDisponibles.isEmpty()) {&#10;            senasUsadas.clear()&#10;            todasLasSenas.random()&#10;        } else {&#10;            senasDisponibles.random()&#10;        }&#10;&#10;        senasUsadas.add(senaParaUsar.id)&#10;&#10;        val respuesta = senaParaUsar.nombre.uppercase()&#10;&#10;        // Generar letras disponibles&#10;        // Incluir TODAS las letras de la respuesta (incluyendo repetidas)&#10;        val letrasRespuesta = respuesta.toList()&#10;        &#10;        // Calcular cuántas letras adicionales necesitamos (máximo 8 total)&#10;        val letrasAdicionalesNecesarias = maxOf(0, 8 - letrasRespuesta.size)&#10;        &#10;        // Generar letras adicionales que NO estén en la respuesta&#10;        val letrasUnicasRespuesta = respuesta.toSet()&#10;        val letrasAdicionales = ('A'..'Z')&#10;            .filter { it !in letrasUnicasRespuesta }&#10;            .shuffled()&#10;            .take(letrasAdicionalesNecesarias)&#10;&#10;        // Combinar todas las letras y mezclarlas&#10;        val todasLetras = (letrasRespuesta + letrasAdicionales).shuffled()&#10;&#10;        return Desafio(&#10;            sena = senaParaUsar,&#10;            respuesta = respuesta,&#10;            letrasDisponibles = todasLetras&#10;        )&#10;    }&#10;&#10;    fun onLetraClick(index: Int) {&#10;        val currentState = _uiState.value&#10;        val desafio = currentState.desafioActual ?: return&#10;&#10;        // Si la letra ya fue usada, no hacer nada&#10;        if (desafio.letrasUsadas[index]) return&#10;&#10;        // Encontrar el primer espacio vacío&#10;        val primerEspacioVacio = desafio.espaciosRespuesta.indexOfFirst { it == null }&#10;&#10;        if (primerEspacioVacio != -1) {&#10;            val letra = desafio.letrasDisponibles[index]&#10;            val nuevosEspacios = desafio.espaciosRespuesta.toMutableList()&#10;            nuevosEspacios[primerEspacioVacio] = letra&#10;&#10;            val nuevasLetrasUsadas = desafio.letrasUsadas.toMutableList()&#10;            nuevasLetrasUsadas[index] = true&#10;&#10;            val desafioActualizado = desafio.copy(&#10;                espaciosRespuesta = nuevosEspacios,&#10;                letrasUsadas = nuevasLetrasUsadas&#10;            )&#10;&#10;            _uiState.value = currentState.copy(desafioActual = desafioActualizado)&#10;        }&#10;    }&#10;&#10;    fun onEspacioClick(espacioIndex: Int) {&#10;        val currentState = _uiState.value&#10;        val desafio = currentState.desafioActual ?: return&#10;&#10;        val letraEnEspacio = desafio.espaciosRespuesta[espacioIndex] ?: return&#10;&#10;        // Encontrar el índice original de esta letra&#10;        val letraIndex = desafio.letrasDisponibles.indexOf(letraEnEspacio)&#10;&#10;        if (letraIndex != -1) {&#10;            val nuevosEspacios = desafio.espaciosRespuesta.toMutableList()&#10;            nuevosEspacios[espacioIndex] = null&#10;&#10;            val nuevasLetrasUsadas = desafio.letrasUsadas.toMutableList()&#10;            nuevasLetrasUsadas[letraIndex] = false&#10;&#10;            val desafioActualizado = desafio.copy(&#10;                espaciosRespuesta = nuevosEspacios,&#10;                letrasUsadas = nuevasLetrasUsadas&#10;            )&#10;&#10;            _uiState.value = currentState.copy(desafioActual = desafioActualizado)&#10;        }&#10;    }&#10;&#10;    fun verificarRespuesta() {&#10;        val currentState = _uiState.value&#10;        val desafio = currentState.desafioActual ?: return&#10;&#10;        // Verificar si todos los espacios están llenos&#10;        if (desafio.espaciosRespuesta.any { it == null }) {&#10;            return&#10;        }&#10;&#10;        val respuestaUsuario = desafio.espaciosRespuesta.joinToString(&quot;&quot;)&#10;        val esCorrecto = respuestaUsuario == desafio.respuesta&#10;&#10;        if (esCorrecto) {&#10;            // Respuesta correcta&#10;            val nuevosDesafiosCorrectos = currentState.desafiosCorrectos + 1&#10;            val puntos = 20 // 20 puntos por respuesta correcta&#10;&#10;            viewModelScope.launch {&#10;                // Actualizar partida&#10;                currentState.partidaId?.let { partidaId -&gt;&#10;                    val partida = PartidaJuegoEntity(&#10;                        id = partidaId,&#10;                        usuarioId = usuarioId,&#10;                        desafiosCompletados = currentState.numeroDesafio,&#10;                        desafiosCorrectos = nuevosDesafiosCorrectos,&#10;                        desafiosIncorrectos = currentState.numeroDesafio - nuevosDesafiosCorrectos,&#10;                        puntosGanados = currentState.puntosGanados + puntos&#10;                    )&#10;                    juegoRepository.actualizarPartida(partida)&#10;                }&#10;            }&#10;&#10;            _uiState.value = currentState.copy(&#10;                mostrarResultado = true,&#10;                esCorrecto = true,&#10;                desafiosCorrectos = nuevosDesafiosCorrectos,&#10;                puntosGanados = currentState.puntosGanados + puntos&#10;            )&#10;        } else {&#10;            // Respuesta incorrecta&#10;            _uiState.value = currentState.copy(&#10;                mostrarResultado = true,&#10;                esCorrecto = false&#10;            )&#10;        }&#10;    }&#10;&#10;    fun continuarJuego() {&#10;        val currentState = _uiState.value&#10;&#10;        if (currentState.esCorrecto) {&#10;            // Si respondió correctamente, avanzar al siguiente desafío&#10;            if (currentState.numeroDesafio &gt;= currentState.totalDesafios) {&#10;                // Juego completado&#10;                finalizarJuego()&#10;            } else {&#10;                // Siguiente desafío&#10;                val nuevoDesafio = generarDesafio()&#10;                if (nuevoDesafio != null) {&#10;                    _uiState.value = currentState.copy(&#10;                        desafioActual = nuevoDesafio,&#10;                        numeroDesafio = currentState.numeroDesafio + 1,&#10;                        mostrarResultado = false,&#10;                        esCorrecto = false&#10;                    )&#10;                } else {&#10;                    _uiState.value = currentState.copy(&#10;                        errorMessage = &quot;Error al generar el siguiente desafío&quot;&#10;                    )&#10;                }&#10;            }&#10;        } else {&#10;            // Si respondió incorrectamente, limpiar espacios para reintentar&#10;            val desafio = currentState.desafioActual ?: return&#10;            _uiState.value = currentState.copy(&#10;                desafioActual = desafio.copy(&#10;                    espaciosRespuesta = List(desafio.respuesta.length) { null },&#10;                    letrasUsadas = List(desafio.letrasDisponibles.size) { false }&#10;                ),&#10;                mostrarResultado = false,&#10;                esCorrecto = false&#10;            )&#10;        }&#10;    }&#10;&#10;    private fun finalizarJuego() {&#10;        viewModelScope.launch {&#10;            val currentState = _uiState.value&#10;            currentState.partidaId?.let { partidaId -&gt;&#10;                juegoRepository.completarPartida(partidaId, usuarioId)&#10;            }&#10;&#10;            _uiState.value = currentState.copy(&#10;                juegoCompletado = true,&#10;                mostrarResultado = false&#10;            )&#10;        }&#10;    }&#10;&#10;    fun reiniciarJuego() {&#10;        iniciarJuego()&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>